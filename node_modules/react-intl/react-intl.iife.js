var ReactIntl = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __defProps = Object.defineProperties;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b)) {
        if (__propIsEnum.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw Error('Dynamic require of "' + x + '" is not supported');
  });
  var __objRest = (source, exclude) => {
    var target = {};
    for (var prop in source)
      if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
        target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(source)) {
        if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
          target[prop] = source[prop];
      }
    return target;
  };
  var __commonJS = (cb, mod2) => function __require2() {
    return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
    mod2
  ));
  var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };

  // node_modules/.aspect_rules_js/react-is@16.13.1/node_modules/react-is/cjs/react-is.development.js
  var require_react_is_development = __commonJS({
    "node_modules/.aspect_rules_js/react-is@16.13.1/node_modules/react-is/cjs/react-is.development.js"(exports) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          var hasSymbol = typeof Symbol === "function" && Symbol.for;
          var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
          var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
          var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
          var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
          var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
          var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
          var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
          var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
          var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
          var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
          var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
          var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
          var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
          var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
          var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
          var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
          var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
          var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
          function isValidElementType(type) {
            return typeof type === "string" || typeof type === "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
            type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
          }
          function typeOf(object) {
            if (typeof object === "object" && object !== null) {
              var $$typeof = object.$$typeof;
              switch ($$typeof) {
                case REACT_ELEMENT_TYPE:
                  var type = object.type;
                  switch (type) {
                    case REACT_ASYNC_MODE_TYPE:
                    case REACT_CONCURRENT_MODE_TYPE:
                    case REACT_FRAGMENT_TYPE:
                    case REACT_PROFILER_TYPE:
                    case REACT_STRICT_MODE_TYPE:
                    case REACT_SUSPENSE_TYPE:
                      return type;
                    default:
                      var $$typeofType = type && type.$$typeof;
                      switch ($$typeofType) {
                        case REACT_CONTEXT_TYPE:
                        case REACT_FORWARD_REF_TYPE:
                        case REACT_LAZY_TYPE:
                        case REACT_MEMO_TYPE:
                        case REACT_PROVIDER_TYPE:
                          return $$typeofType;
                        default:
                          return $$typeof;
                      }
                  }
                case REACT_PORTAL_TYPE:
                  return $$typeof;
              }
            }
            return void 0;
          }
          var AsyncMode = REACT_ASYNC_MODE_TYPE;
          var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
          var ContextConsumer = REACT_CONTEXT_TYPE;
          var ContextProvider = REACT_PROVIDER_TYPE;
          var Element = REACT_ELEMENT_TYPE;
          var ForwardRef = REACT_FORWARD_REF_TYPE;
          var Fragment6 = REACT_FRAGMENT_TYPE;
          var Lazy = REACT_LAZY_TYPE;
          var Memo = REACT_MEMO_TYPE;
          var Portal = REACT_PORTAL_TYPE;
          var Profiler = REACT_PROFILER_TYPE;
          var StrictMode = REACT_STRICT_MODE_TYPE;
          var Suspense = REACT_SUSPENSE_TYPE;
          var hasWarnedAboutDeprecatedIsAsyncMode = false;
          function isAsyncMode(object) {
            {
              if (!hasWarnedAboutDeprecatedIsAsyncMode) {
                hasWarnedAboutDeprecatedIsAsyncMode = true;
                console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
              }
            }
            return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
          }
          function isConcurrentMode(object) {
            return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
          }
          function isContextConsumer(object) {
            return typeOf(object) === REACT_CONTEXT_TYPE;
          }
          function isContextProvider(object) {
            return typeOf(object) === REACT_PROVIDER_TYPE;
          }
          function isElement(object) {
            return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
          }
          function isForwardRef(object) {
            return typeOf(object) === REACT_FORWARD_REF_TYPE;
          }
          function isFragment(object) {
            return typeOf(object) === REACT_FRAGMENT_TYPE;
          }
          function isLazy(object) {
            return typeOf(object) === REACT_LAZY_TYPE;
          }
          function isMemo(object) {
            return typeOf(object) === REACT_MEMO_TYPE;
          }
          function isPortal(object) {
            return typeOf(object) === REACT_PORTAL_TYPE;
          }
          function isProfiler(object) {
            return typeOf(object) === REACT_PROFILER_TYPE;
          }
          function isStrictMode(object) {
            return typeOf(object) === REACT_STRICT_MODE_TYPE;
          }
          function isSuspense(object) {
            return typeOf(object) === REACT_SUSPENSE_TYPE;
          }
          exports.AsyncMode = AsyncMode;
          exports.ConcurrentMode = ConcurrentMode;
          exports.ContextConsumer = ContextConsumer;
          exports.ContextProvider = ContextProvider;
          exports.Element = Element;
          exports.ForwardRef = ForwardRef;
          exports.Fragment = Fragment6;
          exports.Lazy = Lazy;
          exports.Memo = Memo;
          exports.Portal = Portal;
          exports.Profiler = Profiler;
          exports.StrictMode = StrictMode;
          exports.Suspense = Suspense;
          exports.isAsyncMode = isAsyncMode;
          exports.isConcurrentMode = isConcurrentMode;
          exports.isContextConsumer = isContextConsumer;
          exports.isContextProvider = isContextProvider;
          exports.isElement = isElement;
          exports.isForwardRef = isForwardRef;
          exports.isFragment = isFragment;
          exports.isLazy = isLazy;
          exports.isMemo = isMemo;
          exports.isPortal = isPortal;
          exports.isProfiler = isProfiler;
          exports.isStrictMode = isStrictMode;
          exports.isSuspense = isSuspense;
          exports.isValidElementType = isValidElementType;
          exports.typeOf = typeOf;
        })();
      }
    }
  });

  // node_modules/.aspect_rules_js/react-is@16.13.1/node_modules/react-is/index.js
  var require_react_is = __commonJS({
    "node_modules/.aspect_rules_js/react-is@16.13.1/node_modules/react-is/index.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_react_is_development();
      }
    }
  });

  // node_modules/.aspect_rules_js/hoist-non-react-statics@3.3.2/node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js
  var require_hoist_non_react_statics_cjs = __commonJS({
    "node_modules/.aspect_rules_js/hoist-non-react-statics@3.3.2/node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js"(exports, module) {
      "use strict";
      var reactIs = require_react_is();
      var REACT_STATICS = {
        childContextTypes: true,
        contextType: true,
        contextTypes: true,
        defaultProps: true,
        displayName: true,
        getDefaultProps: true,
        getDerivedStateFromError: true,
        getDerivedStateFromProps: true,
        mixins: true,
        propTypes: true,
        type: true
      };
      var KNOWN_STATICS = {
        name: true,
        length: true,
        prototype: true,
        caller: true,
        callee: true,
        arguments: true,
        arity: true
      };
      var FORWARD_REF_STATICS = {
        "$$typeof": true,
        render: true,
        defaultProps: true,
        displayName: true,
        propTypes: true
      };
      var MEMO_STATICS = {
        "$$typeof": true,
        compare: true,
        defaultProps: true,
        displayName: true,
        propTypes: true,
        type: true
      };
      var TYPE_STATICS = {};
      TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
      TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
      function getStatics(component) {
        if (reactIs.isMemo(component)) {
          return MEMO_STATICS;
        }
        return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
      }
      var defineProperty2 = Object.defineProperty;
      var getOwnPropertyNames = Object.getOwnPropertyNames;
      var getOwnPropertySymbols = Object.getOwnPropertySymbols;
      var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
      var getPrototypeOf = Object.getPrototypeOf;
      var objectPrototype = Object.prototype;
      function hoistNonReactStatics2(targetComponent, sourceComponent, blacklist) {
        if (typeof sourceComponent !== "string") {
          if (objectPrototype) {
            var inheritedComponent = getPrototypeOf(sourceComponent);
            if (inheritedComponent && inheritedComponent !== objectPrototype) {
              hoistNonReactStatics2(targetComponent, inheritedComponent, blacklist);
            }
          }
          var keys = getOwnPropertyNames(sourceComponent);
          if (getOwnPropertySymbols) {
            keys = keys.concat(getOwnPropertySymbols(sourceComponent));
          }
          var targetStatics = getStatics(targetComponent);
          var sourceStatics = getStatics(sourceComponent);
          for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
              var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
              try {
                defineProperty2(targetComponent, key, descriptor);
              } catch (e) {
              }
            }
          }
        }
        return targetComponent;
      }
      module.exports = hoistNonReactStatics2;
    }
  });

  // packages/react-intl/index.ts
  var react_intl_exports = {};
  __export(react_intl_exports, {
    FormattedDate: () => FormattedDate,
    FormattedDateParts: () => FormattedDateParts,
    FormattedDateTimeRange: () => dateTimeRange_default,
    FormattedDisplayName: () => FormattedDisplayName,
    FormattedList: () => FormattedList,
    FormattedListParts: () => FormattedListParts,
    FormattedMessage: () => message_default,
    FormattedNumber: () => FormattedNumber,
    FormattedNumberParts: () => FormattedNumberParts,
    FormattedPlural: () => plural_default,
    FormattedRelativeTime: () => relative_default,
    FormattedTime: () => FormattedTime,
    FormattedTimeParts: () => FormattedTimeParts,
    IntlContext: () => Context,
    IntlProvider: () => IntlProvider2,
    InvalidConfigError: () => InvalidConfigError,
    MessageFormatError: () => MessageFormatError,
    MissingDataError: () => MissingDataError,
    MissingTranslationError: () => MissingTranslationError,
    RawIntlProvider: () => Provider,
    ReactIntlError: () => IntlError,
    ReactIntlErrorCode: () => IntlErrorCode,
    UnsupportedFormatterError: () => UnsupportedFormatterError,
    createIntl: () => createIntl2,
    createIntlCache: () => createIntlCache,
    defineMessage: () => defineMessage,
    defineMessages: () => defineMessages,
    injectIntl: () => injectIntl,
    useIntl: () => useIntl
  });

  // packages/react-intl/src/components/createFormattedComponent.tsx
  var React4 = __toESM(window.React);

  // packages/react-intl/src/components/useIntl.ts
  var React3 = __toESM(window.React);

  // packages/react-intl/src/utils.tsx
  var React = __toESM(window.React);

  // node_modules/.aspect_rules_js/@formatjs+icu-skeleton-parser@0.0.0/node_modules/@formatjs/icu-skeleton-parser/date-time.js
  var DATE_TIME_REGEX = /(?:[Eec]{1,6}|G{1,5}|[Qq]{1,5}|(?:[yYur]+|U{1,5})|[ML]{1,5}|d{1,2}|D{1,3}|F{1}|[abB]{1,5}|[hkHK]{1,2}|w{1,2}|W{1}|m{1,2}|s{1,2}|[zZOvVxX]{1,4})(?=([^']*'[^']*')*[^']*$)/g;
  function parseDateTimeSkeleton(skeleton) {
    const result = {};
    skeleton.replace(DATE_TIME_REGEX, (match) => {
      const len = match.length;
      switch (match[0]) {
        case "G":
          result.era = len === 4 ? "long" : len === 5 ? "narrow" : "short";
          break;
        case "y":
          result.year = len === 2 ? "2-digit" : "numeric";
          break;
        case "Y":
        case "u":
        case "U":
        case "r":
          throw new RangeError("`Y/u/U/r` (year) patterns are not supported, use `y` instead");
        case "q":
        case "Q":
          throw new RangeError("`q/Q` (quarter) patterns are not supported");
        case "M":
        case "L":
          result.month = [
            "numeric",
            "2-digit",
            "short",
            "long",
            "narrow"
          ][len - 1];
          break;
        case "w":
        case "W":
          throw new RangeError("`w/W` (week) patterns are not supported");
        case "d":
          result.day = ["numeric", "2-digit"][len - 1];
          break;
        case "D":
        case "F":
        case "g":
          throw new RangeError("`D/F/g` (day) patterns are not supported, use `d` instead");
        case "E":
          result.weekday = len === 4 ? "long" : len === 5 ? "narrow" : "short";
          break;
        case "e":
          if (len < 4) {
            throw new RangeError("`e..eee` (weekday) patterns are not supported");
          }
          result.weekday = [
            "short",
            "long",
            "narrow",
            "short"
          ][len - 4];
          break;
        case "c":
          if (len < 4) {
            throw new RangeError("`c..ccc` (weekday) patterns are not supported");
          }
          result.weekday = [
            "short",
            "long",
            "narrow",
            "short"
          ][len - 4];
          break;
        case "a":
          result.hour12 = true;
          break;
        case "b":
        case "B":
          throw new RangeError("`b/B` (period) patterns are not supported, use `a` instead");
        case "h":
          result.hourCycle = "h12";
          result.hour = ["numeric", "2-digit"][len - 1];
          break;
        case "H":
          result.hourCycle = "h23";
          result.hour = ["numeric", "2-digit"][len - 1];
          break;
        case "K":
          result.hourCycle = "h11";
          result.hour = ["numeric", "2-digit"][len - 1];
          break;
        case "k":
          result.hourCycle = "h24";
          result.hour = ["numeric", "2-digit"][len - 1];
          break;
        case "j":
        case "J":
        case "C":
          throw new RangeError("`j/J/C` (hour) patterns are not supported, use `h/H/K/k` instead");
        case "m":
          result.minute = ["numeric", "2-digit"][len - 1];
          break;
        case "s":
          result.second = ["numeric", "2-digit"][len - 1];
          break;
        case "S":
        case "A":
          throw new RangeError("`S/A` (second) patterns are not supported, use `s` instead");
        case "z":
          result.timeZoneName = len < 4 ? "short" : "long";
          break;
        case "Z":
        case "O":
        case "v":
        case "V":
        case "X":
        case "x":
          throw new RangeError("`Z/O/v/V/X/x` (timeZone) patterns are not supported, use `z` instead");
      }
      return "";
    });
    return result;
  }

  // node_modules/.aspect_rules_js/@formatjs+icu-skeleton-parser@0.0.0/node_modules/@formatjs/icu-skeleton-parser/regex.generated.js
  var WHITE_SPACE_REGEX = /[\t-\r \x85\u200E\u200F\u2028\u2029]/i;

  // node_modules/.aspect_rules_js/@formatjs+icu-skeleton-parser@0.0.0/node_modules/@formatjs/icu-skeleton-parser/number.js
  function parseNumberSkeletonFromString(skeleton) {
    if (skeleton.length === 0) {
      throw new Error("Number skeleton cannot be empty");
    }
    const stringTokens = skeleton.split(WHITE_SPACE_REGEX).filter((x) => x.length > 0);
    const tokens = [];
    for (const stringToken of stringTokens) {
      let stemAndOptions = stringToken.split("/");
      if (stemAndOptions.length === 0) {
        throw new Error("Invalid number skeleton");
      }
      const [stem, ...options] = stemAndOptions;
      for (const option of options) {
        if (option.length === 0) {
          throw new Error("Invalid number skeleton");
        }
      }
      tokens.push({
        stem,
        options
      });
    }
    return tokens;
  }
  function icuUnitToEcma(unit) {
    return unit.replace(/^(.*?)-/, "");
  }
  var FRACTION_PRECISION_REGEX = /^\.(?:(0+)(\*)?|(#+)|(0+)(#+))$/g;
  var SIGNIFICANT_PRECISION_REGEX = /^(@+)?(\+|#+)?[rs]?$/g;
  var INTEGER_WIDTH_REGEX = /(\*)(0+)|(#+)(0+)|(0+)/g;
  var CONCISE_INTEGER_WIDTH_REGEX = /^(0+)$/;
  function parseSignificantPrecision(str) {
    const result = {};
    if (str[str.length - 1] === "r") {
      result.roundingPriority = "morePrecision";
    } else if (str[str.length - 1] === "s") {
      result.roundingPriority = "lessPrecision";
    }
    str.replace(SIGNIFICANT_PRECISION_REGEX, function(_, g1, g2) {
      if (typeof g2 !== "string") {
        result.minimumSignificantDigits = g1.length;
        result.maximumSignificantDigits = g1.length;
      } else if (g2 === "+") {
        result.minimumSignificantDigits = g1.length;
      } else if (g1[0] === "#") {
        result.maximumSignificantDigits = g1.length;
      } else {
        result.minimumSignificantDigits = g1.length;
        result.maximumSignificantDigits = g1.length + (typeof g2 === "string" ? g2.length : 0);
      }
      return "";
    });
    return result;
  }
  function parseSign(str) {
    switch (str) {
      case "sign-auto":
        return { signDisplay: "auto" };
      case "sign-accounting":
      case "()":
        return { currencySign: "accounting" };
      case "sign-always":
      case "+!":
        return { signDisplay: "always" };
      case "sign-accounting-always":
      case "()!":
        return {
          signDisplay: "always",
          currencySign: "accounting"
        };
      case "sign-except-zero":
      case "+?":
        return { signDisplay: "exceptZero" };
      case "sign-accounting-except-zero":
      case "()?":
        return {
          signDisplay: "exceptZero",
          currencySign: "accounting"
        };
      case "sign-never":
      case "+_":
        return { signDisplay: "never" };
    }
  }
  function parseConciseScientificAndEngineeringStem(stem) {
    let result;
    if (stem[0] === "E" && stem[1] === "E") {
      result = { notation: "engineering" };
      stem = stem.slice(2);
    } else if (stem[0] === "E") {
      result = { notation: "scientific" };
      stem = stem.slice(1);
    }
    if (result) {
      const signDisplay = stem.slice(0, 2);
      if (signDisplay === "+!") {
        result.signDisplay = "always";
        stem = stem.slice(2);
      } else if (signDisplay === "+?") {
        result.signDisplay = "exceptZero";
        stem = stem.slice(2);
      }
      if (!CONCISE_INTEGER_WIDTH_REGEX.test(stem)) {
        throw new Error("Malformed concise eng/scientific notation");
      }
      result.minimumIntegerDigits = stem.length;
    }
    return result;
  }
  function parseNotationOptions(opt) {
    const result = {};
    const signOpts = parseSign(opt);
    if (signOpts) {
      return signOpts;
    }
    return result;
  }
  function parseNumberSkeleton(tokens) {
    let result = {};
    for (const token of tokens) {
      switch (token.stem) {
        case "percent":
        case "%":
          result.style = "percent";
          continue;
        case "%x100":
          result.style = "percent";
          result.scale = 100;
          continue;
        case "currency":
          result.style = "currency";
          result.currency = token.options[0];
          continue;
        case "group-off":
        case ",_":
          result.useGrouping = false;
          continue;
        case "precision-integer":
        case ".":
          result.maximumFractionDigits = 0;
          continue;
        case "measure-unit":
        case "unit":
          result.style = "unit";
          result.unit = icuUnitToEcma(token.options[0]);
          continue;
        case "compact-short":
        case "K":
          result.notation = "compact";
          result.compactDisplay = "short";
          continue;
        case "compact-long":
        case "KK":
          result.notation = "compact";
          result.compactDisplay = "long";
          continue;
        case "scientific":
          result = __spreadValues(__spreadProps(__spreadValues({}, result), {
            notation: "scientific"
          }), token.options.reduce((all, opt) => __spreadValues(__spreadValues({}, all), parseNotationOptions(opt)), {}));
          continue;
        case "engineering":
          result = __spreadValues(__spreadProps(__spreadValues({}, result), {
            notation: "engineering"
          }), token.options.reduce((all, opt) => __spreadValues(__spreadValues({}, all), parseNotationOptions(opt)), {}));
          continue;
        case "notation-simple":
          result.notation = "standard";
          continue;
        case "unit-width-narrow":
          result.currencyDisplay = "narrowSymbol";
          result.unitDisplay = "narrow";
          continue;
        case "unit-width-short":
          result.currencyDisplay = "code";
          result.unitDisplay = "short";
          continue;
        case "unit-width-full-name":
          result.currencyDisplay = "name";
          result.unitDisplay = "long";
          continue;
        case "unit-width-iso-code":
          result.currencyDisplay = "symbol";
          continue;
        case "scale":
          result.scale = parseFloat(token.options[0]);
          continue;
        case "rounding-mode-floor":
          result.roundingMode = "floor";
          continue;
        case "rounding-mode-ceiling":
          result.roundingMode = "ceil";
          continue;
        case "rounding-mode-down":
          result.roundingMode = "trunc";
          continue;
        case "rounding-mode-up":
          result.roundingMode = "expand";
          continue;
        case "rounding-mode-half-even":
          result.roundingMode = "halfEven";
          continue;
        case "rounding-mode-half-down":
          result.roundingMode = "halfTrunc";
          continue;
        case "rounding-mode-half-up":
          result.roundingMode = "halfExpand";
          continue;
        case "integer-width":
          if (token.options.length > 1) {
            throw new RangeError("integer-width stems only accept a single optional option");
          }
          token.options[0].replace(INTEGER_WIDTH_REGEX, function(_, g1, g2, g3, g4, g5) {
            if (g1) {
              result.minimumIntegerDigits = g2.length;
            } else if (g3 && g4) {
              throw new Error("We currently do not support maximum integer digits");
            } else if (g5) {
              throw new Error("We currently do not support exact integer digits");
            }
            return "";
          });
          continue;
      }
      if (CONCISE_INTEGER_WIDTH_REGEX.test(token.stem)) {
        result.minimumIntegerDigits = token.stem.length;
        continue;
      }
      if (FRACTION_PRECISION_REGEX.test(token.stem)) {
        if (token.options.length > 1) {
          throw new RangeError("Fraction-precision stems only accept a single optional option");
        }
        token.stem.replace(FRACTION_PRECISION_REGEX, function(_, g1, g2, g3, g4, g5) {
          if (g2 === "*") {
            result.minimumFractionDigits = g1.length;
          } else if (g3 && g3[0] === "#") {
            result.maximumFractionDigits = g3.length;
          } else if (g4 && g5) {
            result.minimumFractionDigits = g4.length;
            result.maximumFractionDigits = g4.length + g5.length;
          } else {
            result.minimumFractionDigits = g1.length;
            result.maximumFractionDigits = g1.length;
          }
          return "";
        });
        const opt = token.options[0];
        if (opt === "w") {
          result = __spreadProps(__spreadValues({}, result), {
            trailingZeroDisplay: "stripIfInteger"
          });
        } else if (opt) {
          result = __spreadValues(__spreadValues({}, result), parseSignificantPrecision(opt));
        }
        continue;
      }
      if (SIGNIFICANT_PRECISION_REGEX.test(token.stem)) {
        result = __spreadValues(__spreadValues({}, result), parseSignificantPrecision(token.stem));
        continue;
      }
      const signOpts = parseSign(token.stem);
      if (signOpts) {
        result = __spreadValues(__spreadValues({}, result), signOpts);
      }
      const conciseScientificAndEngineeringOpts = parseConciseScientificAndEngineeringStem(token.stem);
      if (conciseScientificAndEngineeringOpts) {
        result = __spreadValues(__spreadValues({}, result), conciseScientificAndEngineeringOpts);
      }
    }
    return result;
  }

  // node_modules/.aspect_rules_js/@formatjs+icu-messageformat-parser@0.0.0/node_modules/@formatjs/icu-messageformat-parser/types.js
  var TYPE = function(TYPE2) {
    TYPE2[TYPE2["literal"] = 0] = "literal";
    TYPE2[TYPE2["argument"] = 1] = "argument";
    TYPE2[TYPE2["number"] = 2] = "number";
    TYPE2[TYPE2["date"] = 3] = "date";
    TYPE2[TYPE2["time"] = 4] = "time";
    TYPE2[TYPE2["select"] = 5] = "select";
    TYPE2[TYPE2["plural"] = 6] = "plural";
    TYPE2[TYPE2["pound"] = 7] = "pound";
    TYPE2[TYPE2["tag"] = 8] = "tag";
    return TYPE2;
  }({});
  var SKELETON_TYPE = function(SKELETON_TYPE2) {
    SKELETON_TYPE2[SKELETON_TYPE2["number"] = 0] = "number";
    SKELETON_TYPE2[SKELETON_TYPE2["dateTime"] = 1] = "dateTime";
    return SKELETON_TYPE2;
  }({});
  function isLiteralElement(el) {
    return el.type === TYPE.literal;
  }
  function isArgumentElement(el) {
    return el.type === TYPE.argument;
  }
  function isNumberElement(el) {
    return el.type === TYPE.number;
  }
  function isDateElement(el) {
    return el.type === TYPE.date;
  }
  function isTimeElement(el) {
    return el.type === TYPE.time;
  }
  function isSelectElement(el) {
    return el.type === TYPE.select;
  }
  function isPluralElement(el) {
    return el.type === TYPE.plural;
  }
  function isPoundElement(el) {
    return el.type === TYPE.pound;
  }
  function isTagElement(el) {
    return el.type === TYPE.tag;
  }
  function isNumberSkeleton(el) {
    return !!(el && typeof el === "object" && el.type === SKELETON_TYPE.number);
  }
  function isDateTimeSkeleton(el) {
    return !!(el && typeof el === "object" && el.type === SKELETON_TYPE.dateTime);
  }

  // node_modules/.aspect_rules_js/@formatjs+icu-messageformat-parser@0.0.0/node_modules/@formatjs/icu-messageformat-parser/error.js
  var ErrorKind = function(ErrorKind2) {
    ErrorKind2[ErrorKind2["EXPECT_ARGUMENT_CLOSING_BRACE"] = 1] = "EXPECT_ARGUMENT_CLOSING_BRACE";
    ErrorKind2[ErrorKind2["EMPTY_ARGUMENT"] = 2] = "EMPTY_ARGUMENT";
    ErrorKind2[ErrorKind2["MALFORMED_ARGUMENT"] = 3] = "MALFORMED_ARGUMENT";
    ErrorKind2[ErrorKind2["EXPECT_ARGUMENT_TYPE"] = 4] = "EXPECT_ARGUMENT_TYPE";
    ErrorKind2[ErrorKind2["INVALID_ARGUMENT_TYPE"] = 5] = "INVALID_ARGUMENT_TYPE";
    ErrorKind2[ErrorKind2["EXPECT_ARGUMENT_STYLE"] = 6] = "EXPECT_ARGUMENT_STYLE";
    ErrorKind2[ErrorKind2["INVALID_NUMBER_SKELETON"] = 7] = "INVALID_NUMBER_SKELETON";
    ErrorKind2[ErrorKind2["INVALID_DATE_TIME_SKELETON"] = 8] = "INVALID_DATE_TIME_SKELETON";
    ErrorKind2[ErrorKind2["EXPECT_NUMBER_SKELETON"] = 9] = "EXPECT_NUMBER_SKELETON";
    ErrorKind2[ErrorKind2["EXPECT_DATE_TIME_SKELETON"] = 10] = "EXPECT_DATE_TIME_SKELETON";
    ErrorKind2[ErrorKind2["UNCLOSED_QUOTE_IN_ARGUMENT_STYLE"] = 11] = "UNCLOSED_QUOTE_IN_ARGUMENT_STYLE";
    ErrorKind2[ErrorKind2["EXPECT_SELECT_ARGUMENT_OPTIONS"] = 12] = "EXPECT_SELECT_ARGUMENT_OPTIONS";
    ErrorKind2[ErrorKind2["EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE"] = 13] = "EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE";
    ErrorKind2[ErrorKind2["INVALID_PLURAL_ARGUMENT_OFFSET_VALUE"] = 14] = "INVALID_PLURAL_ARGUMENT_OFFSET_VALUE";
    ErrorKind2[ErrorKind2["EXPECT_SELECT_ARGUMENT_SELECTOR"] = 15] = "EXPECT_SELECT_ARGUMENT_SELECTOR";
    ErrorKind2[ErrorKind2["EXPECT_PLURAL_ARGUMENT_SELECTOR"] = 16] = "EXPECT_PLURAL_ARGUMENT_SELECTOR";
    ErrorKind2[ErrorKind2["EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT"] = 17] = "EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT";
    ErrorKind2[ErrorKind2["EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT"] = 18] = "EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT";
    ErrorKind2[ErrorKind2["INVALID_PLURAL_ARGUMENT_SELECTOR"] = 19] = "INVALID_PLURAL_ARGUMENT_SELECTOR";
    ErrorKind2[ErrorKind2["DUPLICATE_PLURAL_ARGUMENT_SELECTOR"] = 20] = "DUPLICATE_PLURAL_ARGUMENT_SELECTOR";
    ErrorKind2[ErrorKind2["DUPLICATE_SELECT_ARGUMENT_SELECTOR"] = 21] = "DUPLICATE_SELECT_ARGUMENT_SELECTOR";
    ErrorKind2[ErrorKind2["MISSING_OTHER_CLAUSE"] = 22] = "MISSING_OTHER_CLAUSE";
    ErrorKind2[ErrorKind2["INVALID_TAG"] = 23] = "INVALID_TAG";
    ErrorKind2[ErrorKind2["INVALID_TAG_NAME"] = 25] = "INVALID_TAG_NAME";
    ErrorKind2[ErrorKind2["UNMATCHED_CLOSING_TAG"] = 26] = "UNMATCHED_CLOSING_TAG";
    ErrorKind2[ErrorKind2["UNCLOSED_TAG"] = 27] = "UNCLOSED_TAG";
    return ErrorKind2;
  }({});

  // node_modules/.aspect_rules_js/@formatjs+icu-messageformat-parser@0.0.0/node_modules/@formatjs/icu-messageformat-parser/regex.generated.js
  var SPACE_SEPARATOR_REGEX = /[ \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/;

  // node_modules/.aspect_rules_js/@formatjs+icu-messageformat-parser@0.0.0/node_modules/@formatjs/icu-messageformat-parser/time-data.generated.js
  var timeData = {
    "001": ["H", "h"],
    "419": [
      "h",
      "H",
      "hB",
      "hb"
    ],
    "AC": [
      "H",
      "h",
      "hb",
      "hB"
    ],
    "AD": ["H", "hB"],
    "AE": [
      "h",
      "hB",
      "hb",
      "H"
    ],
    "AF": [
      "H",
      "hb",
      "hB",
      "h"
    ],
    "AG": [
      "h",
      "hb",
      "H",
      "hB"
    ],
    "AI": [
      "H",
      "h",
      "hb",
      "hB"
    ],
    "AL": [
      "h",
      "H",
      "hB"
    ],
    "AM": ["H", "hB"],
    "AO": ["H", "hB"],
    "AR": [
      "h",
      "H",
      "hB",
      "hb"
    ],
    "AS": ["h", "H"],
    "AT": ["H", "hB"],
    "AU": [
      "h",
      "hb",
      "H",
      "hB"
    ],
    "AW": ["H", "hB"],
    "AX": ["H"],
    "AZ": [
      "H",
      "hB",
      "h"
    ],
    "BA": [
      "H",
      "hB",
      "h"
    ],
    "BB": [
      "h",
      "hb",
      "H",
      "hB"
    ],
    "BD": [
      "h",
      "hB",
      "H"
    ],
    "BE": ["H", "hB"],
    "BF": ["H", "hB"],
    "BG": [
      "H",
      "hB",
      "h"
    ],
    "BH": [
      "h",
      "hB",
      "hb",
      "H"
    ],
    "BI": ["H", "h"],
    "BJ": ["H", "hB"],
    "BL": ["H", "hB"],
    "BM": [
      "h",
      "hb",
      "H",
      "hB"
    ],
    "BN": [
      "hb",
      "hB",
      "h",
      "H"
    ],
    "BO": [
      "h",
      "H",
      "hB",
      "hb"
    ],
    "BQ": ["H"],
    "BR": ["H", "hB"],
    "BS": [
      "h",
      "hb",
      "H",
      "hB"
    ],
    "BT": ["h", "H"],
    "BW": [
      "H",
      "h",
      "hb",
      "hB"
    ],
    "BY": ["H", "h"],
    "BZ": [
      "H",
      "h",
      "hb",
      "hB"
    ],
    "CA": [
      "h",
      "hb",
      "H",
      "hB"
    ],
    "CC": [
      "H",
      "h",
      "hb",
      "hB"
    ],
    "CD": ["hB", "H"],
    "CF": [
      "H",
      "h",
      "hB"
    ],
    "CG": ["H", "hB"],
    "CH": [
      "H",
      "hB",
      "h"
    ],
    "CI": ["H", "hB"],
    "CK": [
      "H",
      "h",
      "hb",
      "hB"
    ],
    "CL": [
      "h",
      "H",
      "hB",
      "hb"
    ],
    "CM": [
      "H",
      "h",
      "hB"
    ],
    "CN": [
      "H",
      "hB",
      "hb",
      "h"
    ],
    "CO": [
      "h",
      "H",
      "hB",
      "hb"
    ],
    "CP": ["H"],
    "CR": [
      "h",
      "H",
      "hB",
      "hb"
    ],
    "CU": [
      "h",
      "H",
      "hB",
      "hb"
    ],
    "CV": ["H", "hB"],
    "CW": ["H", "hB"],
    "CX": [
      "H",
      "h",
      "hb",
      "hB"
    ],
    "CY": [
      "h",
      "H",
      "hb",
      "hB"
    ],
    "CZ": ["H"],
    "DE": ["H", "hB"],
    "DG": [
      "H",
      "h",
      "hb",
      "hB"
    ],
    "DJ": ["h", "H"],
    "DK": ["H"],
    "DM": [
      "h",
      "hb",
      "H",
      "hB"
    ],
    "DO": [
      "h",
      "H",
      "hB",
      "hb"
    ],
    "DZ": [
      "h",
      "hB",
      "hb",
      "H"
    ],
    "EA": [
      "H",
      "h",
      "hB",
      "hb"
    ],
    "EC": [
      "h",
      "H",
      "hB",
      "hb"
    ],
    "EE": ["H", "hB"],
    "EG": [
      "h",
      "hB",
      "hb",
      "H"
    ],
    "EH": [
      "h",
      "hB",
      "hb",
      "H"
    ],
    "ER": ["h", "H"],
    "ES": [
      "H",
      "hB",
      "h",
      "hb"
    ],
    "ET": [
      "hB",
      "hb",
      "h",
      "H"
    ],
    "FI": ["H"],
    "FJ": [
      "h",
      "hb",
      "H",
      "hB"
    ],
    "FK": [
      "H",
      "h",
      "hb",
      "hB"
    ],
    "FM": [
      "h",
      "hb",
      "H",
      "hB"
    ],
    "FO": ["H", "h"],
    "FR": ["H", "hB"],
    "GA": ["H", "hB"],
    "GB": [
      "H",
      "h",
      "hb",
      "hB"
    ],
    "GD": [
      "h",
      "hb",
      "H",
      "hB"
    ],
    "GE": [
      "H",
      "hB",
      "h"
    ],
    "GF": ["H", "hB"],
    "GG": [
      "H",
      "h",
      "hb",
      "hB"
    ],
    "GH": ["h", "H"],
    "GI": [
      "H",
      "h",
      "hb",
      "hB"
    ],
    "GL": ["H", "h"],
    "GM": [
      "h",
      "hb",
      "H",
      "hB"
    ],
    "GN": ["H", "hB"],
    "GP": ["H", "hB"],
    "GQ": [
      "H",
      "hB",
      "h",
      "hb"
    ],
    "GR": [
      "h",
      "H",
      "hb",
      "hB"
    ],
    "GS": [
      "H",
      "h",
      "hb",
      "hB"
    ],
    "GT": [
      "h",
      "H",
      "hB",
      "hb"
    ],
    "GU": [
      "h",
      "hb",
      "H",
      "hB"
    ],
    "GW": ["H", "hB"],
    "GY": [
      "h",
      "hb",
      "H",
      "hB"
    ],
    "HK": [
      "h",
      "hB",
      "hb",
      "H"
    ],
    "HN": [
      "h",
      "H",
      "hB",
      "hb"
    ],
    "HR": ["H", "hB"],
    "HU": ["H", "h"],
    "IC": [
      "H",
      "h",
      "hB",
      "hb"
    ],
    "ID": ["H"],
    "IE": [
      "H",
      "h",
      "hb",
      "hB"
    ],
    "IL": ["H", "hB"],
    "IM": [
      "H",
      "h",
      "hb",
      "hB"
    ],
    "IN": ["h", "H"],
    "IO": [
      "H",
      "h",
      "hb",
      "hB"
    ],
    "IQ": [
      "h",
      "hB",
      "hb",
      "H"
    ],
    "IR": ["hB", "H"],
    "IS": ["H"],
    "IT": ["H", "hB"],
    "JE": [
      "H",
      "h",
      "hb",
      "hB"
    ],
    "JM": [
      "h",
      "hb",
      "H",
      "hB"
    ],
    "JO": [
      "h",
      "hB",
      "hb",
      "H"
    ],
    "JP": [
      "H",
      "K",
      "h"
    ],
    "KE": [
      "hB",
      "hb",
      "H",
      "h"
    ],
    "KG": [
      "H",
      "h",
      "hB",
      "hb"
    ],
    "KH": [
      "hB",
      "h",
      "H",
      "hb"
    ],
    "KI": [
      "h",
      "hb",
      "H",
      "hB"
    ],
    "KM": [
      "H",
      "h",
      "hB",
      "hb"
    ],
    "KN": [
      "h",
      "hb",
      "H",
      "hB"
    ],
    "KP": [
      "h",
      "H",
      "hB",
      "hb"
    ],
    "KR": [
      "h",
      "H",
      "hB",
      "hb"
    ],
    "KW": [
      "h",
      "hB",
      "hb",
      "H"
    ],
    "KY": [
      "h",
      "hb",
      "H",
      "hB"
    ],
    "KZ": ["H", "hB"],
    "LA": [
      "H",
      "hb",
      "hB",
      "h"
    ],
    "LB": [
      "h",
      "hB",
      "hb",
      "H"
    ],
    "LC": [
      "h",
      "hb",
      "H",
      "hB"
    ],
    "LI": [
      "H",
      "hB",
      "h"
    ],
    "LK": [
      "H",
      "h",
      "hB",
      "hb"
    ],
    "LR": [
      "h",
      "hb",
      "H",
      "hB"
    ],
    "LS": ["h", "H"],
    "LT": [
      "H",
      "h",
      "hb",
      "hB"
    ],
    "LU": [
      "H",
      "h",
      "hB"
    ],
    "LV": [
      "H",
      "hB",
      "hb",
      "h"
    ],
    "LY": [
      "h",
      "hB",
      "hb",
      "H"
    ],
    "MA": [
      "H",
      "h",
      "hB",
      "hb"
    ],
    "MC": ["H", "hB"],
    "MD": ["H", "hB"],
    "ME": [
      "H",
      "hB",
      "h"
    ],
    "MF": ["H", "hB"],
    "MG": ["H", "h"],
    "MH": [
      "h",
      "hb",
      "H",
      "hB"
    ],
    "MK": [
      "H",
      "h",
      "hb",
      "hB"
    ],
    "ML": ["H"],
    "MM": [
      "hB",
      "hb",
      "H",
      "h"
    ],
    "MN": [
      "H",
      "h",
      "hb",
      "hB"
    ],
    "MO": [
      "h",
      "hB",
      "hb",
      "H"
    ],
    "MP": [
      "h",
      "hb",
      "H",
      "hB"
    ],
    "MQ": ["H", "hB"],
    "MR": [
      "h",
      "hB",
      "hb",
      "H"
    ],
    "MS": [
      "H",
      "h",
      "hb",
      "hB"
    ],
    "MT": ["H", "h"],
    "MU": ["H", "h"],
    "MV": ["H", "h"],
    "MW": [
      "h",
      "hb",
      "H",
      "hB"
    ],
    "MX": [
      "h",
      "H",
      "hB",
      "hb"
    ],
    "MY": [
      "hb",
      "hB",
      "h",
      "H"
    ],
    "MZ": ["H", "hB"],
    "NA": [
      "h",
      "H",
      "hB",
      "hb"
    ],
    "NC": ["H", "hB"],
    "NE": ["H"],
    "NF": [
      "H",
      "h",
      "hb",
      "hB"
    ],
    "NG": [
      "H",
      "h",
      "hb",
      "hB"
    ],
    "NI": [
      "h",
      "H",
      "hB",
      "hb"
    ],
    "NL": ["H", "hB"],
    "NO": ["H", "h"],
    "NP": [
      "H",
      "h",
      "hB"
    ],
    "NR": [
      "H",
      "h",
      "hb",
      "hB"
    ],
    "NU": [
      "H",
      "h",
      "hb",
      "hB"
    ],
    "NZ": [
      "h",
      "hb",
      "H",
      "hB"
    ],
    "OM": [
      "h",
      "hB",
      "hb",
      "H"
    ],
    "PA": [
      "h",
      "H",
      "hB",
      "hb"
    ],
    "PE": [
      "h",
      "H",
      "hB",
      "hb"
    ],
    "PF": [
      "H",
      "h",
      "hB"
    ],
    "PG": ["h", "H"],
    "PH": [
      "h",
      "hB",
      "hb",
      "H"
    ],
    "PK": [
      "h",
      "hB",
      "H"
    ],
    "PL": ["H", "h"],
    "PM": ["H", "hB"],
    "PN": [
      "H",
      "h",
      "hb",
      "hB"
    ],
    "PR": [
      "h",
      "H",
      "hB",
      "hb"
    ],
    "PS": [
      "h",
      "hB",
      "hb",
      "H"
    ],
    "PT": ["H", "hB"],
    "PW": ["h", "H"],
    "PY": [
      "h",
      "H",
      "hB",
      "hb"
    ],
    "QA": [
      "h",
      "hB",
      "hb",
      "H"
    ],
    "RE": ["H", "hB"],
    "RO": ["H", "hB"],
    "RS": [
      "H",
      "hB",
      "h"
    ],
    "RU": ["H"],
    "RW": ["H", "h"],
    "SA": [
      "h",
      "hB",
      "hb",
      "H"
    ],
    "SB": [
      "h",
      "hb",
      "H",
      "hB"
    ],
    "SC": [
      "H",
      "h",
      "hB"
    ],
    "SD": [
      "h",
      "hB",
      "hb",
      "H"
    ],
    "SE": ["H"],
    "SG": [
      "h",
      "hb",
      "H",
      "hB"
    ],
    "SH": [
      "H",
      "h",
      "hb",
      "hB"
    ],
    "SI": ["H", "hB"],
    "SJ": ["H"],
    "SK": ["H"],
    "SL": [
      "h",
      "hb",
      "H",
      "hB"
    ],
    "SM": [
      "H",
      "h",
      "hB"
    ],
    "SN": [
      "H",
      "h",
      "hB"
    ],
    "SO": ["h", "H"],
    "SR": ["H", "hB"],
    "SS": [
      "h",
      "hb",
      "H",
      "hB"
    ],
    "ST": ["H", "hB"],
    "SV": [
      "h",
      "H",
      "hB",
      "hb"
    ],
    "SX": [
      "H",
      "h",
      "hb",
      "hB"
    ],
    "SY": [
      "h",
      "hB",
      "hb",
      "H"
    ],
    "SZ": [
      "h",
      "hb",
      "H",
      "hB"
    ],
    "TA": [
      "H",
      "h",
      "hb",
      "hB"
    ],
    "TC": [
      "h",
      "hb",
      "H",
      "hB"
    ],
    "TD": [
      "h",
      "H",
      "hB"
    ],
    "TF": [
      "H",
      "h",
      "hB"
    ],
    "TG": ["H", "hB"],
    "TH": ["H", "h"],
    "TJ": ["H", "h"],
    "TL": [
      "H",
      "hB",
      "hb",
      "h"
    ],
    "TM": ["H", "h"],
    "TN": [
      "h",
      "hB",
      "hb",
      "H"
    ],
    "TO": ["h", "H"],
    "TR": ["H", "hB"],
    "TT": [
      "h",
      "hb",
      "H",
      "hB"
    ],
    "TW": [
      "hB",
      "hb",
      "h",
      "H"
    ],
    "TZ": [
      "hB",
      "hb",
      "H",
      "h"
    ],
    "UA": [
      "H",
      "hB",
      "h"
    ],
    "UG": [
      "hB",
      "hb",
      "H",
      "h"
    ],
    "UM": [
      "h",
      "hb",
      "H",
      "hB"
    ],
    "US": [
      "h",
      "hb",
      "H",
      "hB"
    ],
    "UY": [
      "h",
      "H",
      "hB",
      "hb"
    ],
    "UZ": [
      "H",
      "hB",
      "h"
    ],
    "VA": [
      "H",
      "h",
      "hB"
    ],
    "VC": [
      "h",
      "hb",
      "H",
      "hB"
    ],
    "VE": [
      "h",
      "H",
      "hB",
      "hb"
    ],
    "VG": [
      "h",
      "hb",
      "H",
      "hB"
    ],
    "VI": [
      "h",
      "hb",
      "H",
      "hB"
    ],
    "VN": ["H", "h"],
    "VU": ["h", "H"],
    "WF": ["H", "hB"],
    "WS": ["h", "H"],
    "XK": [
      "H",
      "hB",
      "h"
    ],
    "YE": [
      "h",
      "hB",
      "hb",
      "H"
    ],
    "YT": ["H", "hB"],
    "ZA": [
      "H",
      "h",
      "hb",
      "hB"
    ],
    "ZM": [
      "h",
      "hb",
      "H",
      "hB"
    ],
    "ZW": ["H", "h"],
    "af-ZA": [
      "H",
      "h",
      "hB",
      "hb"
    ],
    "ar-001": [
      "h",
      "hB",
      "hb",
      "H"
    ],
    "ca-ES": [
      "H",
      "h",
      "hB"
    ],
    "en-001": [
      "h",
      "hb",
      "H",
      "hB"
    ],
    "en-HK": [
      "h",
      "hb",
      "H",
      "hB"
    ],
    "en-IL": [
      "H",
      "h",
      "hb",
      "hB"
    ],
    "en-MY": [
      "h",
      "hb",
      "H",
      "hB"
    ],
    "es-BR": [
      "H",
      "h",
      "hB",
      "hb"
    ],
    "es-ES": [
      "H",
      "h",
      "hB",
      "hb"
    ],
    "es-GQ": [
      "H",
      "h",
      "hB",
      "hb"
    ],
    "fr-CA": [
      "H",
      "h",
      "hB"
    ],
    "gl-ES": [
      "H",
      "h",
      "hB"
    ],
    "gu-IN": [
      "hB",
      "hb",
      "h",
      "H"
    ],
    "hi-IN": [
      "hB",
      "h",
      "H"
    ],
    "it-CH": [
      "H",
      "h",
      "hB"
    ],
    "it-IT": [
      "H",
      "h",
      "hB"
    ],
    "kn-IN": [
      "hB",
      "h",
      "H"
    ],
    "ku-SY": ["H", "hB"],
    "ml-IN": [
      "hB",
      "h",
      "H"
    ],
    "mr-IN": [
      "hB",
      "hb",
      "h",
      "H"
    ],
    "pa-IN": [
      "hB",
      "hb",
      "h",
      "H"
    ],
    "ta-IN": [
      "hB",
      "h",
      "hb",
      "H"
    ],
    "te-IN": [
      "hB",
      "h",
      "H"
    ],
    "zu-ZA": [
      "H",
      "hB",
      "hb",
      "h"
    ]
  };

  // node_modules/.aspect_rules_js/@formatjs+icu-messageformat-parser@0.0.0/node_modules/@formatjs/icu-messageformat-parser/date-time-pattern-generator.js
  function getBestPattern(skeleton, locale) {
    let skeletonCopy = "";
    for (let patternPos = 0; patternPos < skeleton.length; patternPos++) {
      const patternChar = skeleton.charAt(patternPos);
      if (patternChar === "j") {
        let extraLength = 0;
        while (patternPos + 1 < skeleton.length && skeleton.charAt(patternPos + 1) === patternChar) {
          extraLength++;
          patternPos++;
        }
        let hourLen = 1 + (extraLength & 1);
        let dayPeriodLen = extraLength < 2 ? 1 : 3 + (extraLength >> 1);
        let dayPeriodChar = "a";
        let hourChar = getDefaultHourSymbolFromLocale(locale);
        if (hourChar == "H" || hourChar == "k") {
          dayPeriodLen = 0;
        }
        while (dayPeriodLen-- > 0) {
          skeletonCopy += dayPeriodChar;
        }
        while (hourLen-- > 0) {
          skeletonCopy = hourChar + skeletonCopy;
        }
      } else if (patternChar === "J") {
        skeletonCopy += "H";
      } else {
        skeletonCopy += patternChar;
      }
    }
    return skeletonCopy;
  }
  function getDefaultHourSymbolFromLocale(locale) {
    let hourCycle = locale.hourCycle;
    if (hourCycle === void 0 && locale.hourCycles && locale.hourCycles.length) {
      hourCycle = locale.hourCycles[0];
    }
    if (hourCycle) {
      switch (hourCycle) {
        case "h24":
          return "k";
        case "h23":
          return "H";
        case "h12":
          return "h";
        case "h11":
          return "K";
        default:
          throw new Error("Invalid hourCycle");
      }
    }
    const languageTag = locale.language;
    let regionTag;
    if (languageTag !== "root") {
      regionTag = locale.maximize().region;
    }
    const hourCycles = timeData[regionTag || ""] || timeData[languageTag || ""] || timeData[`${languageTag}-001`] || timeData["001"];
    return hourCycles[0];
  }

  // node_modules/.aspect_rules_js/@formatjs+icu-messageformat-parser@0.0.0/node_modules/@formatjs/icu-messageformat-parser/parser.js
  var SPACE_SEPARATOR_START_REGEX = new RegExp(`^${SPACE_SEPARATOR_REGEX.source}*`);
  var SPACE_SEPARATOR_END_REGEX = new RegExp(`${SPACE_SEPARATOR_REGEX.source}*$`);
  function createLocation(start, end) {
    return {
      start,
      end
    };
  }
  var hasNativeFromEntries = !!Object.fromEntries;
  var hasTrimStart = !!String.prototype.trimStart;
  var hasTrimEnd = !!String.prototype.trimEnd;
  var fromEntries = hasNativeFromEntries ? Object.fromEntries : function fromEntries2(entries) {
    const obj = {};
    for (const [k, v] of entries) {
      obj[k] = v;
    }
    return obj;
  };
  var trimStart = hasTrimStart ? function trimStart2(s) {
    return s.trimStart();
  } : function trimStart3(s) {
    return s.replace(SPACE_SEPARATOR_START_REGEX, "");
  };
  var trimEnd = hasTrimEnd ? function trimEnd2(s) {
    return s.trimEnd();
  } : function trimEnd3(s) {
    return s.replace(SPACE_SEPARATOR_END_REGEX, "");
  };
  var IDENTIFIER_PREFIX_RE = new RegExp("([^\\p{White_Space}\\p{Pattern_Syntax}]*)", "yu");
  function matchIdentifierAtIndex(s, index) {
    var _a2;
    IDENTIFIER_PREFIX_RE.lastIndex = index;
    const match = IDENTIFIER_PREFIX_RE.exec(s);
    return (_a2 = match[1]) != null ? _a2 : "";
  }
  var Parser = class {
    constructor(message, options = {}) {
      __publicField(this, "message");
      __publicField(this, "position");
      __publicField(this, "locale");
      __publicField(this, "ignoreTag");
      __publicField(this, "requiresOtherClause");
      __publicField(this, "shouldParseSkeletons");
      this.message = message;
      this.position = {
        offset: 0,
        line: 1,
        column: 1
      };
      this.ignoreTag = !!options.ignoreTag;
      this.locale = options.locale;
      this.requiresOtherClause = !!options.requiresOtherClause;
      this.shouldParseSkeletons = !!options.shouldParseSkeletons;
    }
    parse() {
      if (this.offset() !== 0) {
        throw Error("parser can only be used once");
      }
      return this.parseMessage(0, "", false);
    }
    parseMessage(nestingLevel, parentArgType, expectingCloseTag) {
      let elements = [];
      while (!this.isEOF()) {
        const char = this.char();
        if (char === 123) {
          const result = this.parseArgument(nestingLevel, expectingCloseTag);
          if (result.err) {
            return result;
          }
          elements.push(result.val);
        } else if (char === 125 && nestingLevel > 0) {
          break;
        } else if (char === 35 && (parentArgType === "plural" || parentArgType === "selectordinal")) {
          const position = this.clonePosition();
          this.bump();
          elements.push({
            type: TYPE.pound,
            location: createLocation(position, this.clonePosition())
          });
        } else if (char === 60 && !this.ignoreTag && this.peek() === 47) {
          if (expectingCloseTag) {
            break;
          } else {
            return this.error(ErrorKind.UNMATCHED_CLOSING_TAG, createLocation(this.clonePosition(), this.clonePosition()));
          }
        } else if (char === 60 && !this.ignoreTag && _isAlpha(this.peek() || 0)) {
          const result = this.parseTag(nestingLevel, parentArgType);
          if (result.err) {
            return result;
          }
          elements.push(result.val);
        } else {
          const result = this.parseLiteral(nestingLevel, parentArgType);
          if (result.err) {
            return result;
          }
          elements.push(result.val);
        }
      }
      return {
        val: elements,
        err: null
      };
    }
    /**
    * A tag name must start with an ASCII lower/upper case letter. The grammar is based on the
    * [custom element name][] except that a dash is NOT always mandatory and uppercase letters
    * are accepted:
    *
    * ```
    * tag ::= "<" tagName (whitespace)* "/>" | "<" tagName (whitespace)* ">" message "</" tagName (whitespace)* ">"
    * tagName ::= [a-z] (PENChar)*
    * PENChar ::=
    *     "-" | "." | [0-9] | "_" | [a-z] | [A-Z] | #xB7 | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x37D] |
    *     [#x37F-#x1FFF] | [#x200C-#x200D] | [#x203F-#x2040] | [#x2070-#x218F] | [#x2C00-#x2FEF] |
    *     [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]
    * ```
    *
    * [custom element name]: https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name
    * NOTE: We're a bit more lax here since HTML technically does not allow uppercase HTML element but we do
    * since other tag-based engines like React allow it
    */
    parseTag(nestingLevel, parentArgType) {
      const startPosition = this.clonePosition();
      this.bump();
      const tagName = this.parseTagName();
      this.bumpSpace();
      if (this.bumpIf("/>")) {
        return {
          val: {
            type: TYPE.literal,
            value: `<${tagName}/>`,
            location: createLocation(startPosition, this.clonePosition())
          },
          err: null
        };
      } else if (this.bumpIf(">")) {
        const childrenResult = this.parseMessage(nestingLevel + 1, parentArgType, true);
        if (childrenResult.err) {
          return childrenResult;
        }
        const children = childrenResult.val;
        const endTagStartPosition = this.clonePosition();
        if (this.bumpIf("</")) {
          if (this.isEOF() || !_isAlpha(this.char())) {
            return this.error(ErrorKind.INVALID_TAG, createLocation(endTagStartPosition, this.clonePosition()));
          }
          const closingTagNameStartPosition = this.clonePosition();
          const closingTagName = this.parseTagName();
          if (tagName !== closingTagName) {
            return this.error(ErrorKind.UNMATCHED_CLOSING_TAG, createLocation(closingTagNameStartPosition, this.clonePosition()));
          }
          this.bumpSpace();
          if (!this.bumpIf(">")) {
            return this.error(ErrorKind.INVALID_TAG, createLocation(endTagStartPosition, this.clonePosition()));
          }
          return {
            val: {
              type: TYPE.tag,
              value: tagName,
              children,
              location: createLocation(startPosition, this.clonePosition())
            },
            err: null
          };
        } else {
          return this.error(ErrorKind.UNCLOSED_TAG, createLocation(startPosition, this.clonePosition()));
        }
      } else {
        return this.error(ErrorKind.INVALID_TAG, createLocation(startPosition, this.clonePosition()));
      }
    }
    /**
    * This method assumes that the caller has peeked ahead for the first tag character.
    */
    parseTagName() {
      const startOffset = this.offset();
      this.bump();
      while (!this.isEOF() && _isPotentialElementNameChar(this.char())) {
        this.bump();
      }
      return this.message.slice(startOffset, this.offset());
    }
    parseLiteral(nestingLevel, parentArgType) {
      const start = this.clonePosition();
      let value = "";
      while (true) {
        const parseQuoteResult = this.tryParseQuote(parentArgType);
        if (parseQuoteResult) {
          value += parseQuoteResult;
          continue;
        }
        const parseUnquotedResult = this.tryParseUnquoted(nestingLevel, parentArgType);
        if (parseUnquotedResult) {
          value += parseUnquotedResult;
          continue;
        }
        const parseLeftAngleResult = this.tryParseLeftAngleBracket();
        if (parseLeftAngleResult) {
          value += parseLeftAngleResult;
          continue;
        }
        break;
      }
      const location = createLocation(start, this.clonePosition());
      return {
        val: {
          type: TYPE.literal,
          value,
          location
        },
        err: null
      };
    }
    tryParseLeftAngleBracket() {
      if (!this.isEOF() && this.char() === 60 && (this.ignoreTag || !_isAlphaOrSlash(this.peek() || 0))) {
        this.bump();
        return "<";
      }
      return null;
    }
    /**
    * Starting with ICU 4.8, an ASCII apostrophe only starts quoted text if it immediately precedes
    * a character that requires quoting (that is, "only where needed"), and works the same in
    * nested messages as on the top level of the pattern. The new behavior is otherwise compatible.
    */
    tryParseQuote(parentArgType) {
      if (this.isEOF() || this.char() !== 39) {
        return null;
      }
      switch (this.peek()) {
        case 39:
          this.bump();
          this.bump();
          return "'";
        case 123:
        case 60:
        case 62:
        case 125:
          break;
        case 35:
          if (parentArgType === "plural" || parentArgType === "selectordinal") {
            break;
          }
          return null;
        default:
          return null;
      }
      this.bump();
      const codePoints = [this.char()];
      this.bump();
      while (!this.isEOF()) {
        const ch = this.char();
        if (ch === 39) {
          if (this.peek() === 39) {
            codePoints.push(39);
            this.bump();
          } else {
            this.bump();
            break;
          }
        } else {
          codePoints.push(ch);
        }
        this.bump();
      }
      return String.fromCodePoint(...codePoints);
    }
    tryParseUnquoted(nestingLevel, parentArgType) {
      if (this.isEOF()) {
        return null;
      }
      const ch = this.char();
      if (ch === 60 || ch === 123 || ch === 35 && (parentArgType === "plural" || parentArgType === "selectordinal") || ch === 125 && nestingLevel > 0) {
        return null;
      } else {
        this.bump();
        return String.fromCodePoint(ch);
      }
    }
    parseArgument(nestingLevel, expectingCloseTag) {
      const openingBracePosition = this.clonePosition();
      this.bump();
      this.bumpSpace();
      if (this.isEOF()) {
        return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
      }
      if (this.char() === 125) {
        this.bump();
        return this.error(ErrorKind.EMPTY_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));
      }
      let value = this.parseIdentifierIfPossible().value;
      if (!value) {
        return this.error(ErrorKind.MALFORMED_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));
      }
      this.bumpSpace();
      if (this.isEOF()) {
        return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
      }
      switch (this.char()) {
        case 125: {
          this.bump();
          return {
            val: {
              type: TYPE.argument,
              value,
              location: createLocation(openingBracePosition, this.clonePosition())
            },
            err: null
          };
        }
        case 44: {
          this.bump();
          this.bumpSpace();
          if (this.isEOF()) {
            return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
          }
          return this.parseArgumentOptions(nestingLevel, expectingCloseTag, value, openingBracePosition);
        }
        default:
          return this.error(ErrorKind.MALFORMED_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));
      }
    }
    /**
    * Advance the parser until the end of the identifier, if it is currently on
    * an identifier character. Return an empty string otherwise.
    */
    parseIdentifierIfPossible() {
      const startingPosition = this.clonePosition();
      const startOffset = this.offset();
      const value = matchIdentifierAtIndex(this.message, startOffset);
      const endOffset = startOffset + value.length;
      this.bumpTo(endOffset);
      const endPosition = this.clonePosition();
      const location = createLocation(startingPosition, endPosition);
      return {
        value,
        location
      };
    }
    parseArgumentOptions(nestingLevel, expectingCloseTag, value, openingBracePosition) {
      var _a2;
      let typeStartPosition = this.clonePosition();
      let argType = this.parseIdentifierIfPossible().value;
      let typeEndPosition = this.clonePosition();
      switch (argType) {
        case "":
          return this.error(ErrorKind.EXPECT_ARGUMENT_TYPE, createLocation(typeStartPosition, typeEndPosition));
        case "number":
        case "date":
        case "time": {
          this.bumpSpace();
          let styleAndLocation = null;
          if (this.bumpIf(",")) {
            this.bumpSpace();
            const styleStartPosition = this.clonePosition();
            const result = this.parseSimpleArgStyleIfPossible();
            if (result.err) {
              return result;
            }
            const style = trimEnd(result.val);
            if (style.length === 0) {
              return this.error(ErrorKind.EXPECT_ARGUMENT_STYLE, createLocation(this.clonePosition(), this.clonePosition()));
            }
            const styleLocation = createLocation(styleStartPosition, this.clonePosition());
            styleAndLocation = {
              style,
              styleLocation
            };
          }
          const argCloseResult = this.tryParseArgumentClose(openingBracePosition);
          if (argCloseResult.err) {
            return argCloseResult;
          }
          const location = createLocation(openingBracePosition, this.clonePosition());
          if (styleAndLocation && styleAndLocation.style.startsWith("::")) {
            let skeleton = trimStart(styleAndLocation.style.slice(2));
            if (argType === "number") {
              const result = this.parseNumberSkeletonFromString(skeleton, styleAndLocation.styleLocation);
              if (result.err) {
                return result;
              }
              return {
                val: {
                  type: TYPE.number,
                  value,
                  location,
                  style: result.val
                },
                err: null
              };
            } else {
              if (skeleton.length === 0) {
                return this.error(ErrorKind.EXPECT_DATE_TIME_SKELETON, location);
              }
              let dateTimePattern = skeleton;
              if (this.locale) {
                dateTimePattern = getBestPattern(skeleton, this.locale);
              }
              const style = {
                type: SKELETON_TYPE.dateTime,
                pattern: dateTimePattern,
                location: styleAndLocation.styleLocation,
                parsedOptions: this.shouldParseSkeletons ? parseDateTimeSkeleton(dateTimePattern) : {}
              };
              const type = argType === "date" ? TYPE.date : TYPE.time;
              return {
                val: {
                  type,
                  value,
                  location,
                  style
                },
                err: null
              };
            }
          }
          return {
            val: {
              type: argType === "number" ? TYPE.number : argType === "date" ? TYPE.date : TYPE.time,
              value,
              location,
              style: (_a2 = styleAndLocation == null ? void 0 : styleAndLocation.style) != null ? _a2 : null
            },
            err: null
          };
        }
        case "plural":
        case "selectordinal":
        case "select": {
          const typeEndPosition2 = this.clonePosition();
          this.bumpSpace();
          if (!this.bumpIf(",")) {
            return this.error(ErrorKind.EXPECT_SELECT_ARGUMENT_OPTIONS, createLocation(typeEndPosition2, __spreadValues({}, typeEndPosition2)));
          }
          this.bumpSpace();
          let identifierAndLocation = this.parseIdentifierIfPossible();
          let pluralOffset = 0;
          if (argType !== "select" && identifierAndLocation.value === "offset") {
            if (!this.bumpIf(":")) {
              return this.error(ErrorKind.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, createLocation(this.clonePosition(), this.clonePosition()));
            }
            this.bumpSpace();
            const result = this.tryParseDecimalInteger(ErrorKind.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, ErrorKind.INVALID_PLURAL_ARGUMENT_OFFSET_VALUE);
            if (result.err) {
              return result;
            }
            this.bumpSpace();
            identifierAndLocation = this.parseIdentifierIfPossible();
            pluralOffset = result.val;
          }
          const optionsResult = this.tryParsePluralOrSelectOptions(nestingLevel, argType, expectingCloseTag, identifierAndLocation);
          if (optionsResult.err) {
            return optionsResult;
          }
          const argCloseResult = this.tryParseArgumentClose(openingBracePosition);
          if (argCloseResult.err) {
            return argCloseResult;
          }
          const location = createLocation(openingBracePosition, this.clonePosition());
          if (argType === "select") {
            return {
              val: {
                type: TYPE.select,
                value,
                options: fromEntries(optionsResult.val),
                location
              },
              err: null
            };
          } else {
            return {
              val: {
                type: TYPE.plural,
                value,
                options: fromEntries(optionsResult.val),
                offset: pluralOffset,
                pluralType: argType === "plural" ? "cardinal" : "ordinal",
                location
              },
              err: null
            };
          }
        }
        default:
          return this.error(ErrorKind.INVALID_ARGUMENT_TYPE, createLocation(typeStartPosition, typeEndPosition));
      }
    }
    tryParseArgumentClose(openingBracePosition) {
      if (this.isEOF() || this.char() !== 125) {
        return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
      }
      this.bump();
      return {
        val: true,
        err: null
      };
    }
    /**
    * See: https://github.com/unicode-org/icu/blob/af7ed1f6d2298013dc303628438ec4abe1f16479/icu4c/source/common/messagepattern.cpp#L659
    */
    parseSimpleArgStyleIfPossible() {
      let nestedBraces = 0;
      const startPosition = this.clonePosition();
      while (!this.isEOF()) {
        const ch = this.char();
        switch (ch) {
          case 39: {
            this.bump();
            let apostrophePosition = this.clonePosition();
            if (!this.bumpUntil("'")) {
              return this.error(ErrorKind.UNCLOSED_QUOTE_IN_ARGUMENT_STYLE, createLocation(apostrophePosition, this.clonePosition()));
            }
            this.bump();
            break;
          }
          case 123: {
            nestedBraces += 1;
            this.bump();
            break;
          }
          case 125: {
            if (nestedBraces > 0) {
              nestedBraces -= 1;
            } else {
              return {
                val: this.message.slice(startPosition.offset, this.offset()),
                err: null
              };
            }
            break;
          }
          default:
            this.bump();
            break;
        }
      }
      return {
        val: this.message.slice(startPosition.offset, this.offset()),
        err: null
      };
    }
    parseNumberSkeletonFromString(skeleton, location) {
      let tokens = [];
      try {
        tokens = parseNumberSkeletonFromString(skeleton);
      } catch (e) {
        return this.error(ErrorKind.INVALID_NUMBER_SKELETON, location);
      }
      return {
        val: {
          type: SKELETON_TYPE.number,
          tokens,
          location,
          parsedOptions: this.shouldParseSkeletons ? parseNumberSkeleton(tokens) : {}
        },
        err: null
      };
    }
    /**
    * @param nesting_level The current nesting level of messages.
    *     This can be positive when parsing message fragment in select or plural argument options.
    * @param parent_arg_type The parent argument's type.
    * @param parsed_first_identifier If provided, this is the first identifier-like selector of
    *     the argument. It is a by-product of a previous parsing attempt.
    * @param expecting_close_tag If true, this message is directly or indirectly nested inside
    *     between a pair of opening and closing tags. The nested message will not parse beyond
    *     the closing tag boundary.
    */
    tryParsePluralOrSelectOptions(nestingLevel, parentArgType, expectCloseTag, parsedFirstIdentifier) {
      let hasOtherClause = false;
      const options = [];
      const parsedSelectors = /* @__PURE__ */ new Set();
      let { value: selector, location: selectorLocation } = parsedFirstIdentifier;
      while (true) {
        if (selector.length === 0) {
          const startPosition = this.clonePosition();
          if (parentArgType !== "select" && this.bumpIf("=")) {
            const result = this.tryParseDecimalInteger(ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR, ErrorKind.INVALID_PLURAL_ARGUMENT_SELECTOR);
            if (result.err) {
              return result;
            }
            selectorLocation = createLocation(startPosition, this.clonePosition());
            selector = this.message.slice(startPosition.offset, this.offset());
          } else {
            break;
          }
        }
        if (parsedSelectors.has(selector)) {
          return this.error(parentArgType === "select" ? ErrorKind.DUPLICATE_SELECT_ARGUMENT_SELECTOR : ErrorKind.DUPLICATE_PLURAL_ARGUMENT_SELECTOR, selectorLocation);
        }
        if (selector === "other") {
          hasOtherClause = true;
        }
        this.bumpSpace();
        const openingBracePosition = this.clonePosition();
        if (!this.bumpIf("{")) {
          return this.error(parentArgType === "select" ? ErrorKind.EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT : ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT, createLocation(this.clonePosition(), this.clonePosition()));
        }
        const fragmentResult = this.parseMessage(nestingLevel + 1, parentArgType, expectCloseTag);
        if (fragmentResult.err) {
          return fragmentResult;
        }
        const argCloseResult = this.tryParseArgumentClose(openingBracePosition);
        if (argCloseResult.err) {
          return argCloseResult;
        }
        options.push([selector, {
          value: fragmentResult.val,
          location: createLocation(openingBracePosition, this.clonePosition())
        }]);
        parsedSelectors.add(selector);
        this.bumpSpace();
        ({ value: selector, location: selectorLocation } = this.parseIdentifierIfPossible());
      }
      if (options.length === 0) {
        return this.error(parentArgType === "select" ? ErrorKind.EXPECT_SELECT_ARGUMENT_SELECTOR : ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR, createLocation(this.clonePosition(), this.clonePosition()));
      }
      if (this.requiresOtherClause && !hasOtherClause) {
        return this.error(ErrorKind.MISSING_OTHER_CLAUSE, createLocation(this.clonePosition(), this.clonePosition()));
      }
      return {
        val: options,
        err: null
      };
    }
    tryParseDecimalInteger(expectNumberError, invalidNumberError) {
      let sign2 = 1;
      const startingPosition = this.clonePosition();
      if (this.bumpIf("+")) {
      } else if (this.bumpIf("-")) {
        sign2 = -1;
      }
      let hasDigits = false;
      let decimal = 0;
      while (!this.isEOF()) {
        const ch = this.char();
        if (ch >= 48 && ch <= 57) {
          hasDigits = true;
          decimal = decimal * 10 + (ch - 48);
          this.bump();
        } else {
          break;
        }
      }
      const location = createLocation(startingPosition, this.clonePosition());
      if (!hasDigits) {
        return this.error(expectNumberError, location);
      }
      decimal *= sign2;
      if (!Number.isSafeInteger(decimal)) {
        return this.error(invalidNumberError, location);
      }
      return {
        val: decimal,
        err: null
      };
    }
    offset() {
      return this.position.offset;
    }
    isEOF() {
      return this.offset() === this.message.length;
    }
    clonePosition() {
      return {
        offset: this.position.offset,
        line: this.position.line,
        column: this.position.column
      };
    }
    /**
    * Return the code point at the current position of the parser.
    * Throws if the index is out of bound.
    */
    char() {
      const offset = this.position.offset;
      if (offset >= this.message.length) {
        throw Error("out of bound");
      }
      const code = this.message.codePointAt(offset);
      if (code === void 0) {
        throw Error(`Offset ${offset} is at invalid UTF-16 code unit boundary`);
      }
      return code;
    }
    error(kind, location) {
      return {
        val: null,
        err: {
          kind,
          message: this.message,
          location
        }
      };
    }
    /** Bump the parser to the next UTF-16 code unit. */
    bump() {
      if (this.isEOF()) {
        return;
      }
      const code = this.char();
      if (code === 10) {
        this.position.line += 1;
        this.position.column = 1;
        this.position.offset += 1;
      } else {
        this.position.column += 1;
        this.position.offset += code < 65536 ? 1 : 2;
      }
    }
    /**
    * If the substring starting at the current position of the parser has
    * the given prefix, then bump the parser to the character immediately
    * following the prefix and return true. Otherwise, don't bump the parser
    * and return false.
    */
    bumpIf(prefix) {
      if (this.message.startsWith(prefix, this.offset())) {
        for (let i = 0; i < prefix.length; i++) {
          this.bump();
        }
        return true;
      }
      return false;
    }
    /**
    * Bump the parser until the pattern character is found and return `true`.
    * Otherwise bump to the end of the file and return `false`.
    */
    bumpUntil(pattern) {
      const currentOffset = this.offset();
      const index = this.message.indexOf(pattern, currentOffset);
      if (index >= 0) {
        this.bumpTo(index);
        return true;
      } else {
        this.bumpTo(this.message.length);
        return false;
      }
    }
    /**
    * Bump the parser to the target offset.
    * If target offset is beyond the end of the input, bump the parser to the end of the input.
    */
    bumpTo(targetOffset) {
      if (this.offset() > targetOffset) {
        throw Error(`targetOffset ${targetOffset} must be greater than or equal to the current offset ${this.offset()}`);
      }
      targetOffset = Math.min(targetOffset, this.message.length);
      while (true) {
        const offset = this.offset();
        if (offset === targetOffset) {
          break;
        }
        if (offset > targetOffset) {
          throw Error(`targetOffset ${targetOffset} is at invalid UTF-16 code unit boundary`);
        }
        this.bump();
        if (this.isEOF()) {
          break;
        }
      }
    }
    /** advance the parser through all whitespace to the next non-whitespace code unit. */
    bumpSpace() {
      while (!this.isEOF() && _isWhiteSpace(this.char())) {
        this.bump();
      }
    }
    /**
    * Peek at the *next* Unicode codepoint in the input without advancing the parser.
    * If the input has been exhausted, then this returns null.
    */
    peek() {
      if (this.isEOF()) {
        return null;
      }
      const code = this.char();
      const offset = this.offset();
      const nextCode = this.message.charCodeAt(offset + (code >= 65536 ? 2 : 1));
      return nextCode != null ? nextCode : null;
    }
  };
  function _isAlpha(codepoint) {
    return codepoint >= 97 && codepoint <= 122 || codepoint >= 65 && codepoint <= 90;
  }
  function _isAlphaOrSlash(codepoint) {
    return _isAlpha(codepoint) || codepoint === 47;
  }
  function _isPotentialElementNameChar(c) {
    return c === 45 || c === 46 || c >= 48 && c <= 57 || c === 95 || c >= 97 && c <= 122 || c >= 65 && c <= 90 || c == 183 || c >= 192 && c <= 214 || c >= 216 && c <= 246 || c >= 248 && c <= 893 || c >= 895 && c <= 8191 || c >= 8204 && c <= 8205 || c >= 8255 && c <= 8256 || c >= 8304 && c <= 8591 || c >= 11264 && c <= 12271 || c >= 12289 && c <= 55295 || c >= 63744 && c <= 64975 || c >= 65008 && c <= 65533 || c >= 65536 && c <= 983039;
  }
  function _isWhiteSpace(c) {
    return c >= 9 && c <= 13 || c === 32 || c === 133 || c >= 8206 && c <= 8207 || c === 8232 || c === 8233;
  }

  // node_modules/.aspect_rules_js/@formatjs+icu-messageformat-parser@0.0.0/node_modules/@formatjs/icu-messageformat-parser/index.js
  function pruneLocation(els) {
    els.forEach((el) => {
      delete el.location;
      if (isSelectElement(el) || isPluralElement(el)) {
        for (const k in el.options) {
          delete el.options[k].location;
          pruneLocation(el.options[k].value);
        }
      } else if (isNumberElement(el) && isNumberSkeleton(el.style)) {
        delete el.style.location;
      } else if ((isDateElement(el) || isTimeElement(el)) && isDateTimeSkeleton(el.style)) {
        delete el.style.location;
      } else if (isTagElement(el)) {
        pruneLocation(el.children);
      }
    });
  }
  function parse(message, opts = {}) {
    opts = __spreadValues({
      shouldParseSkeletons: true,
      requiresOtherClause: true
    }, opts);
    const result = new Parser(message, opts).parse();
    if (result.err) {
      const error = SyntaxError(ErrorKind[result.err.kind]);
      error.location = result.err.location;
      error.originalMessage = result.err.message;
      throw error;
    }
    if (!(opts == null ? void 0 : opts.captureLocation)) {
      pruneLocation(result.val);
    }
    return result.val;
  }

  // node_modules/.aspect_rules_js/decimal.js@10.6.0/node_modules/decimal.js/decimal.mjs
  var EXP_LIMIT = 9e15;
  var MAX_DIGITS = 1e9;
  var NUMERALS = "0123456789abcdef";
  var LN10 = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058";
  var PI = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789";
  var DEFAULTS = {
    // These values must be integers within the stated ranges (inclusive).
    // Most of these values can be changed at run-time using the `Decimal.config` method.
    // The maximum number of significant digits of the result of a calculation or base conversion.
    // E.g. `Decimal.config({ precision: 20 });`
    precision: 20,
    // 1 to MAX_DIGITS
    // The rounding mode used when rounding to `precision`.
    //
    // ROUND_UP         0 Away from zero.
    // ROUND_DOWN       1 Towards zero.
    // ROUND_CEIL       2 Towards +Infinity.
    // ROUND_FLOOR      3 Towards -Infinity.
    // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
    // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
    // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
    // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
    // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
    //
    // E.g.
    // `Decimal.rounding = 4;`
    // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
    rounding: 4,
    // 0 to 8
    // The modulo mode used when calculating the modulus: a mod n.
    // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
    // The remainder (r) is calculated as: r = a - n * q.
    //
    // UP         0 The remainder is positive if the dividend is negative, else is negative.
    // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).
    // FLOOR      3 The remainder has the same sign as the divisor (Python %).
    // HALF_EVEN  6 The IEEE 754 remainder function.
    // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.
    //
    // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian
    // division (9) are commonly used for the modulus operation. The other rounding modes can also
    // be used, but they may not give useful results.
    modulo: 1,
    // 0 to 9
    // The exponent value at and beneath which `toString` returns exponential notation.
    // JavaScript numbers: -7
    toExpNeg: -7,
    // 0 to -EXP_LIMIT
    // The exponent value at and above which `toString` returns exponential notation.
    // JavaScript numbers: 21
    toExpPos: 21,
    // 0 to EXP_LIMIT
    // The minimum exponent value, beneath which underflow to zero occurs.
    // JavaScript numbers: -324  (5e-324)
    minE: -EXP_LIMIT,
    // -1 to -EXP_LIMIT
    // The maximum exponent value, above which overflow to Infinity occurs.
    // JavaScript numbers: 308  (1.7976931348623157e+308)
    maxE: EXP_LIMIT,
    // 1 to EXP_LIMIT
    // Whether to use cryptographically-secure random number generation, if available.
    crypto: false
    // true/false
  };
  var inexact;
  var quadrant;
  var external = true;
  var decimalError = "[DecimalError] ";
  var invalidArgument = decimalError + "Invalid argument: ";
  var precisionLimitExceeded = decimalError + "Precision limit exceeded";
  var cryptoUnavailable = decimalError + "crypto unavailable";
  var tag = "[object Decimal]";
  var mathfloor = Math.floor;
  var mathpow = Math.pow;
  var isBinary = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i;
  var isHex = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i;
  var isOctal = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i;
  var isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
  var BASE = 1e7;
  var LOG_BASE = 7;
  var MAX_SAFE_INTEGER = 9007199254740991;
  var LN10_PRECISION = LN10.length - 1;
  var PI_PRECISION = PI.length - 1;
  var P = { toStringTag: tag };
  P.absoluteValue = P.abs = function() {
    var x = new this.constructor(this);
    if (x.s < 0)
      x.s = 1;
    return finalise(x);
  };
  P.ceil = function() {
    return finalise(new this.constructor(this), this.e + 1, 2);
  };
  P.clampedTo = P.clamp = function(min2, max2) {
    var k, x = this, Ctor = x.constructor;
    min2 = new Ctor(min2);
    max2 = new Ctor(max2);
    if (!min2.s || !max2.s)
      return new Ctor(NaN);
    if (min2.gt(max2))
      throw Error(invalidArgument + max2);
    k = x.cmp(min2);
    return k < 0 ? min2 : x.cmp(max2) > 0 ? max2 : new Ctor(x);
  };
  P.comparedTo = P.cmp = function(y) {
    var i, j, xdL, ydL, x = this, xd = x.d, yd = (y = new x.constructor(y)).d, xs = x.s, ys = y.s;
    if (!xd || !yd) {
      return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;
    }
    if (!xd[0] || !yd[0])
      return xd[0] ? xs : yd[0] ? -ys : 0;
    if (xs !== ys)
      return xs;
    if (x.e !== y.e)
      return x.e > y.e ^ xs < 0 ? 1 : -1;
    xdL = xd.length;
    ydL = yd.length;
    for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {
      if (xd[i] !== yd[i])
        return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;
    }
    return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;
  };
  P.cosine = P.cos = function() {
    var pr, rm, x = this, Ctor = x.constructor;
    if (!x.d)
      return new Ctor(NaN);
    if (!x.d[0])
      return new Ctor(1);
    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
    Ctor.rounding = 1;
    x = cosine(Ctor, toLessThanHalfPi(Ctor, x));
    Ctor.precision = pr;
    Ctor.rounding = rm;
    return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);
  };
  P.cubeRoot = P.cbrt = function() {
    var e, m, n, r, rep, s, sd, t, t3, t3plusx, x = this, Ctor = x.constructor;
    if (!x.isFinite() || x.isZero())
      return new Ctor(x);
    external = false;
    s = x.s * mathpow(x.s * x, 1 / 3);
    if (!s || Math.abs(s) == 1 / 0) {
      n = digitsToString(x.d);
      e = x.e;
      if (s = (e - n.length + 1) % 3)
        n += s == 1 || s == -2 ? "0" : "00";
      s = mathpow(n, 1 / 3);
      e = mathfloor((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));
      if (s == 1 / 0) {
        n = "5e" + e;
      } else {
        n = s.toExponential();
        n = n.slice(0, n.indexOf("e") + 1) + e;
      }
      r = new Ctor(n);
      r.s = x.s;
    } else {
      r = new Ctor(s.toString());
    }
    sd = (e = Ctor.precision) + 3;
    for (; ; ) {
      t = r;
      t3 = t.times(t).times(t);
      t3plusx = t3.plus(x);
      r = divide(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);
      if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
        n = n.slice(sd - 3, sd + 1);
        if (n == "9999" || !rep && n == "4999") {
          if (!rep) {
            finalise(t, e + 1, 0);
            if (t.times(t).times(t).eq(x)) {
              r = t;
              break;
            }
          }
          sd += 4;
          rep = 1;
        } else {
          if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
            finalise(r, e + 1, 1);
            m = !r.times(r).times(r).eq(x);
          }
          break;
        }
      }
    }
    external = true;
    return finalise(r, e, Ctor.rounding, m);
  };
  P.decimalPlaces = P.dp = function() {
    var w, d = this.d, n = NaN;
    if (d) {
      w = d.length - 1;
      n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE;
      w = d[w];
      if (w)
        for (; w % 10 == 0; w /= 10)
          n--;
      if (n < 0)
        n = 0;
    }
    return n;
  };
  P.dividedBy = P.div = function(y) {
    return divide(this, new this.constructor(y));
  };
  P.dividedToIntegerBy = P.divToInt = function(y) {
    var x = this, Ctor = x.constructor;
    return finalise(divide(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);
  };
  P.equals = P.eq = function(y) {
    return this.cmp(y) === 0;
  };
  P.floor = function() {
    return finalise(new this.constructor(this), this.e + 1, 3);
  };
  P.greaterThan = P.gt = function(y) {
    return this.cmp(y) > 0;
  };
  P.greaterThanOrEqualTo = P.gte = function(y) {
    var k = this.cmp(y);
    return k == 1 || k === 0;
  };
  P.hyperbolicCosine = P.cosh = function() {
    var k, n, pr, rm, len, x = this, Ctor = x.constructor, one = new Ctor(1);
    if (!x.isFinite())
      return new Ctor(x.s ? 1 / 0 : NaN);
    if (x.isZero())
      return one;
    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
    Ctor.rounding = 1;
    len = x.d.length;
    if (len < 32) {
      k = Math.ceil(len / 3);
      n = (1 / tinyPow(4, k)).toString();
    } else {
      k = 16;
      n = "2.3283064365386962890625e-10";
    }
    x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);
    var cosh2_x, i = k, d8 = new Ctor(8);
    for (; i--; ) {
      cosh2_x = x.times(x);
      x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));
    }
    return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);
  };
  P.hyperbolicSine = P.sinh = function() {
    var k, pr, rm, len, x = this, Ctor = x.constructor;
    if (!x.isFinite() || x.isZero())
      return new Ctor(x);
    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
    Ctor.rounding = 1;
    len = x.d.length;
    if (len < 3) {
      x = taylorSeries(Ctor, 2, x, x, true);
    } else {
      k = 1.4 * Math.sqrt(len);
      k = k > 16 ? 16 : k | 0;
      x = x.times(1 / tinyPow(5, k));
      x = taylorSeries(Ctor, 2, x, x, true);
      var sinh2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
      for (; k--; ) {
        sinh2_x = x.times(x);
        x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));
      }
    }
    Ctor.precision = pr;
    Ctor.rounding = rm;
    return finalise(x, pr, rm, true);
  };
  P.hyperbolicTangent = P.tanh = function() {
    var pr, rm, x = this, Ctor = x.constructor;
    if (!x.isFinite())
      return new Ctor(x.s);
    if (x.isZero())
      return new Ctor(x);
    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + 7;
    Ctor.rounding = 1;
    return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);
  };
  P.inverseCosine = P.acos = function() {
    var x = this, Ctor = x.constructor, k = x.abs().cmp(1), pr = Ctor.precision, rm = Ctor.rounding;
    if (k !== -1) {
      return k === 0 ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0) : new Ctor(NaN);
    }
    if (x.isZero())
      return getPi(Ctor, pr + 4, rm).times(0.5);
    Ctor.precision = pr + 6;
    Ctor.rounding = 1;
    x = new Ctor(1).minus(x).div(x.plus(1)).sqrt().atan();
    Ctor.precision = pr;
    Ctor.rounding = rm;
    return x.times(2);
  };
  P.inverseHyperbolicCosine = P.acosh = function() {
    var pr, rm, x = this, Ctor = x.constructor;
    if (x.lte(1))
      return new Ctor(x.eq(1) ? 0 : NaN);
    if (!x.isFinite())
      return new Ctor(x);
    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;
    Ctor.rounding = 1;
    external = false;
    x = x.times(x).minus(1).sqrt().plus(x);
    external = true;
    Ctor.precision = pr;
    Ctor.rounding = rm;
    return x.ln();
  };
  P.inverseHyperbolicSine = P.asinh = function() {
    var pr, rm, x = this, Ctor = x.constructor;
    if (!x.isFinite() || x.isZero())
      return new Ctor(x);
    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;
    Ctor.rounding = 1;
    external = false;
    x = x.times(x).plus(1).sqrt().plus(x);
    external = true;
    Ctor.precision = pr;
    Ctor.rounding = rm;
    return x.ln();
  };
  P.inverseHyperbolicTangent = P.atanh = function() {
    var pr, rm, wpr, xsd, x = this, Ctor = x.constructor;
    if (!x.isFinite())
      return new Ctor(NaN);
    if (x.e >= 0)
      return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);
    pr = Ctor.precision;
    rm = Ctor.rounding;
    xsd = x.sd();
    if (Math.max(xsd, pr) < 2 * -x.e - 1)
      return finalise(new Ctor(x), pr, rm, true);
    Ctor.precision = wpr = xsd - x.e;
    x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);
    Ctor.precision = pr + 4;
    Ctor.rounding = 1;
    x = x.ln();
    Ctor.precision = pr;
    Ctor.rounding = rm;
    return x.times(0.5);
  };
  P.inverseSine = P.asin = function() {
    var halfPi, k, pr, rm, x = this, Ctor = x.constructor;
    if (x.isZero())
      return new Ctor(x);
    k = x.abs().cmp(1);
    pr = Ctor.precision;
    rm = Ctor.rounding;
    if (k !== -1) {
      if (k === 0) {
        halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
        halfPi.s = x.s;
        return halfPi;
      }
      return new Ctor(NaN);
    }
    Ctor.precision = pr + 6;
    Ctor.rounding = 1;
    x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();
    Ctor.precision = pr;
    Ctor.rounding = rm;
    return x.times(2);
  };
  P.inverseTangent = P.atan = function() {
    var i, j, k, n, px, t, r, wpr, x2, x = this, Ctor = x.constructor, pr = Ctor.precision, rm = Ctor.rounding;
    if (!x.isFinite()) {
      if (!x.s)
        return new Ctor(NaN);
      if (pr + 4 <= PI_PRECISION) {
        r = getPi(Ctor, pr + 4, rm).times(0.5);
        r.s = x.s;
        return r;
      }
    } else if (x.isZero()) {
      return new Ctor(x);
    } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {
      r = getPi(Ctor, pr + 4, rm).times(0.25);
      r.s = x.s;
      return r;
    }
    Ctor.precision = wpr = pr + 10;
    Ctor.rounding = 1;
    k = Math.min(28, wpr / LOG_BASE + 2 | 0);
    for (i = k; i; --i)
      x = x.div(x.times(x).plus(1).sqrt().plus(1));
    external = false;
    j = Math.ceil(wpr / LOG_BASE);
    n = 1;
    x2 = x.times(x);
    r = new Ctor(x);
    px = x;
    for (; i !== -1; ) {
      px = px.times(x2);
      t = r.minus(px.div(n += 2));
      px = px.times(x2);
      r = t.plus(px.div(n += 2));
      if (r.d[j] !== void 0)
        for (i = j; r.d[i] === t.d[i] && i--; )
          ;
    }
    if (k)
      r = r.times(2 << k - 1);
    external = true;
    return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);
  };
  P.isFinite = function() {
    return !!this.d;
  };
  P.isInteger = P.isInt = function() {
    return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;
  };
  P.isNaN = function() {
    return !this.s;
  };
  P.isNegative = P.isNeg = function() {
    return this.s < 0;
  };
  P.isPositive = P.isPos = function() {
    return this.s > 0;
  };
  P.isZero = function() {
    return !!this.d && this.d[0] === 0;
  };
  P.lessThan = P.lt = function(y) {
    return this.cmp(y) < 0;
  };
  P.lessThanOrEqualTo = P.lte = function(y) {
    return this.cmp(y) < 1;
  };
  P.logarithm = P.log = function(base) {
    var isBase10, d, denominator, k, inf, num, sd, r, arg = this, Ctor = arg.constructor, pr = Ctor.precision, rm = Ctor.rounding, guard = 5;
    if (base == null) {
      base = new Ctor(10);
      isBase10 = true;
    } else {
      base = new Ctor(base);
      d = base.d;
      if (base.s < 0 || !d || !d[0] || base.eq(1))
        return new Ctor(NaN);
      isBase10 = base.eq(10);
    }
    d = arg.d;
    if (arg.s < 0 || !d || !d[0] || arg.eq(1)) {
      return new Ctor(d && !d[0] ? -1 / 0 : arg.s != 1 ? NaN : d ? 0 : 1 / 0);
    }
    if (isBase10) {
      if (d.length > 1) {
        inf = true;
      } else {
        for (k = d[0]; k % 10 === 0; )
          k /= 10;
        inf = k !== 1;
      }
    }
    external = false;
    sd = pr + guard;
    num = naturalLogarithm(arg, sd);
    denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
    r = divide(num, denominator, sd, 1);
    if (checkRoundingDigits(r.d, k = pr, rm)) {
      do {
        sd += 10;
        num = naturalLogarithm(arg, sd);
        denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
        r = divide(num, denominator, sd, 1);
        if (!inf) {
          if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {
            r = finalise(r, pr + 1, 0);
          }
          break;
        }
      } while (checkRoundingDigits(r.d, k += 10, rm));
    }
    external = true;
    return finalise(r, pr, rm);
  };
  P.minus = P.sub = function(y) {
    var d, e, i, j, k, len, pr, rm, xd, xe, xLTy, yd, x = this, Ctor = x.constructor;
    y = new Ctor(y);
    if (!x.d || !y.d) {
      if (!x.s || !y.s)
        y = new Ctor(NaN);
      else if (x.d)
        y.s = -y.s;
      else
        y = new Ctor(y.d || x.s !== y.s ? x : NaN);
      return y;
    }
    if (x.s != y.s) {
      y.s = -y.s;
      return x.plus(y);
    }
    xd = x.d;
    yd = y.d;
    pr = Ctor.precision;
    rm = Ctor.rounding;
    if (!xd[0] || !yd[0]) {
      if (yd[0])
        y.s = -y.s;
      else if (xd[0])
        y = new Ctor(x);
      else
        return new Ctor(rm === 3 ? -0 : 0);
      return external ? finalise(y, pr, rm) : y;
    }
    e = mathfloor(y.e / LOG_BASE);
    xe = mathfloor(x.e / LOG_BASE);
    xd = xd.slice();
    k = xe - e;
    if (k) {
      xLTy = k < 0;
      if (xLTy) {
        d = xd;
        k = -k;
        len = yd.length;
      } else {
        d = yd;
        e = xe;
        len = xd.length;
      }
      i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;
      if (k > i) {
        k = i;
        d.length = 1;
      }
      d.reverse();
      for (i = k; i--; )
        d.push(0);
      d.reverse();
    } else {
      i = xd.length;
      len = yd.length;
      xLTy = i < len;
      if (xLTy)
        len = i;
      for (i = 0; i < len; i++) {
        if (xd[i] != yd[i]) {
          xLTy = xd[i] < yd[i];
          break;
        }
      }
      k = 0;
    }
    if (xLTy) {
      d = xd;
      xd = yd;
      yd = d;
      y.s = -y.s;
    }
    len = xd.length;
    for (i = yd.length - len; i > 0; --i)
      xd[len++] = 0;
    for (i = yd.length; i > k; ) {
      if (xd[--i] < yd[i]) {
        for (j = i; j && xd[--j] === 0; )
          xd[j] = BASE - 1;
        --xd[j];
        xd[i] += BASE;
      }
      xd[i] -= yd[i];
    }
    for (; xd[--len] === 0; )
      xd.pop();
    for (; xd[0] === 0; xd.shift())
      --e;
    if (!xd[0])
      return new Ctor(rm === 3 ? -0 : 0);
    y.d = xd;
    y.e = getBase10Exponent(xd, e);
    return external ? finalise(y, pr, rm) : y;
  };
  P.modulo = P.mod = function(y) {
    var q, x = this, Ctor = x.constructor;
    y = new Ctor(y);
    if (!x.d || !y.s || y.d && !y.d[0])
      return new Ctor(NaN);
    if (!y.d || x.d && !x.d[0]) {
      return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);
    }
    external = false;
    if (Ctor.modulo == 9) {
      q = divide(x, y.abs(), 0, 3, 1);
      q.s *= y.s;
    } else {
      q = divide(x, y, 0, Ctor.modulo, 1);
    }
    q = q.times(y);
    external = true;
    return x.minus(q);
  };
  P.naturalExponential = P.exp = function() {
    return naturalExponential(this);
  };
  P.naturalLogarithm = P.ln = function() {
    return naturalLogarithm(this);
  };
  P.negated = P.neg = function() {
    var x = new this.constructor(this);
    x.s = -x.s;
    return finalise(x);
  };
  P.plus = P.add = function(y) {
    var carry, d, e, i, k, len, pr, rm, xd, yd, x = this, Ctor = x.constructor;
    y = new Ctor(y);
    if (!x.d || !y.d) {
      if (!x.s || !y.s)
        y = new Ctor(NaN);
      else if (!x.d)
        y = new Ctor(y.d || x.s === y.s ? x : NaN);
      return y;
    }
    if (x.s != y.s) {
      y.s = -y.s;
      return x.minus(y);
    }
    xd = x.d;
    yd = y.d;
    pr = Ctor.precision;
    rm = Ctor.rounding;
    if (!xd[0] || !yd[0]) {
      if (!yd[0])
        y = new Ctor(x);
      return external ? finalise(y, pr, rm) : y;
    }
    k = mathfloor(x.e / LOG_BASE);
    e = mathfloor(y.e / LOG_BASE);
    xd = xd.slice();
    i = k - e;
    if (i) {
      if (i < 0) {
        d = xd;
        i = -i;
        len = yd.length;
      } else {
        d = yd;
        e = k;
        len = xd.length;
      }
      k = Math.ceil(pr / LOG_BASE);
      len = k > len ? k + 1 : len + 1;
      if (i > len) {
        i = len;
        d.length = 1;
      }
      d.reverse();
      for (; i--; )
        d.push(0);
      d.reverse();
    }
    len = xd.length;
    i = yd.length;
    if (len - i < 0) {
      i = len;
      d = yd;
      yd = xd;
      xd = d;
    }
    for (carry = 0; i; ) {
      carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;
      xd[i] %= BASE;
    }
    if (carry) {
      xd.unshift(carry);
      ++e;
    }
    for (len = xd.length; xd[--len] == 0; )
      xd.pop();
    y.d = xd;
    y.e = getBase10Exponent(xd, e);
    return external ? finalise(y, pr, rm) : y;
  };
  P.precision = P.sd = function(z) {
    var k, x = this;
    if (z !== void 0 && z !== !!z && z !== 1 && z !== 0)
      throw Error(invalidArgument + z);
    if (x.d) {
      k = getPrecision(x.d);
      if (z && x.e + 1 > k)
        k = x.e + 1;
    } else {
      k = NaN;
    }
    return k;
  };
  P.round = function() {
    var x = this, Ctor = x.constructor;
    return finalise(new Ctor(x), x.e + 1, Ctor.rounding);
  };
  P.sine = P.sin = function() {
    var pr, rm, x = this, Ctor = x.constructor;
    if (!x.isFinite())
      return new Ctor(NaN);
    if (x.isZero())
      return new Ctor(x);
    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
    Ctor.rounding = 1;
    x = sine(Ctor, toLessThanHalfPi(Ctor, x));
    Ctor.precision = pr;
    Ctor.rounding = rm;
    return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);
  };
  P.squareRoot = P.sqrt = function() {
    var m, n, sd, r, rep, t, x = this, d = x.d, e = x.e, s = x.s, Ctor = x.constructor;
    if (s !== 1 || !d || !d[0]) {
      return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);
    }
    external = false;
    s = Math.sqrt(+x);
    if (s == 0 || s == 1 / 0) {
      n = digitsToString(d);
      if ((n.length + e) % 2 == 0)
        n += "0";
      s = Math.sqrt(n);
      e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);
      if (s == 1 / 0) {
        n = "5e" + e;
      } else {
        n = s.toExponential();
        n = n.slice(0, n.indexOf("e") + 1) + e;
      }
      r = new Ctor(n);
    } else {
      r = new Ctor(s.toString());
    }
    sd = (e = Ctor.precision) + 3;
    for (; ; ) {
      t = r;
      r = t.plus(divide(x, t, sd + 2, 1)).times(0.5);
      if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
        n = n.slice(sd - 3, sd + 1);
        if (n == "9999" || !rep && n == "4999") {
          if (!rep) {
            finalise(t, e + 1, 0);
            if (t.times(t).eq(x)) {
              r = t;
              break;
            }
          }
          sd += 4;
          rep = 1;
        } else {
          if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
            finalise(r, e + 1, 1);
            m = !r.times(r).eq(x);
          }
          break;
        }
      }
    }
    external = true;
    return finalise(r, e, Ctor.rounding, m);
  };
  P.tangent = P.tan = function() {
    var pr, rm, x = this, Ctor = x.constructor;
    if (!x.isFinite())
      return new Ctor(NaN);
    if (x.isZero())
      return new Ctor(x);
    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + 10;
    Ctor.rounding = 1;
    x = x.sin();
    x.s = 1;
    x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);
    Ctor.precision = pr;
    Ctor.rounding = rm;
    return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);
  };
  P.times = P.mul = function(y) {
    var carry, e, i, k, r, rL, t, xdL, ydL, x = this, Ctor = x.constructor, xd = x.d, yd = (y = new Ctor(y)).d;
    y.s *= x.s;
    if (!xd || !xd[0] || !yd || !yd[0]) {
      return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd ? NaN : !xd || !yd ? y.s / 0 : y.s * 0);
    }
    e = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);
    xdL = xd.length;
    ydL = yd.length;
    if (xdL < ydL) {
      r = xd;
      xd = yd;
      yd = r;
      rL = xdL;
      xdL = ydL;
      ydL = rL;
    }
    r = [];
    rL = xdL + ydL;
    for (i = rL; i--; )
      r.push(0);
    for (i = ydL; --i >= 0; ) {
      carry = 0;
      for (k = xdL + i; k > i; ) {
        t = r[k] + yd[i] * xd[k - i - 1] + carry;
        r[k--] = t % BASE | 0;
        carry = t / BASE | 0;
      }
      r[k] = (r[k] + carry) % BASE | 0;
    }
    for (; !r[--rL]; )
      r.pop();
    if (carry)
      ++e;
    else
      r.shift();
    y.d = r;
    y.e = getBase10Exponent(r, e);
    return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;
  };
  P.toBinary = function(sd, rm) {
    return toStringBinary(this, 2, sd, rm);
  };
  P.toDecimalPlaces = P.toDP = function(dp, rm) {
    var x = this, Ctor = x.constructor;
    x = new Ctor(x);
    if (dp === void 0)
      return x;
    checkInt32(dp, 0, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
    return finalise(x, dp + x.e + 1, rm);
  };
  P.toExponential = function(dp, rm) {
    var str, x = this, Ctor = x.constructor;
    if (dp === void 0) {
      str = finiteToString(x, true);
    } else {
      checkInt32(dp, 0, MAX_DIGITS);
      if (rm === void 0)
        rm = Ctor.rounding;
      else
        checkInt32(rm, 0, 8);
      x = finalise(new Ctor(x), dp + 1, rm);
      str = finiteToString(x, true, dp + 1);
    }
    return x.isNeg() && !x.isZero() ? "-" + str : str;
  };
  P.toFixed = function(dp, rm) {
    var str, y, x = this, Ctor = x.constructor;
    if (dp === void 0) {
      str = finiteToString(x);
    } else {
      checkInt32(dp, 0, MAX_DIGITS);
      if (rm === void 0)
        rm = Ctor.rounding;
      else
        checkInt32(rm, 0, 8);
      y = finalise(new Ctor(x), dp + x.e + 1, rm);
      str = finiteToString(y, false, dp + y.e + 1);
    }
    return x.isNeg() && !x.isZero() ? "-" + str : str;
  };
  P.toFraction = function(maxD) {
    var d, d0, d1, d2, e, k, n, n0, n1, pr, q, r, x = this, xd = x.d, Ctor = x.constructor;
    if (!xd)
      return new Ctor(x);
    n1 = d0 = new Ctor(1);
    d1 = n0 = new Ctor(0);
    d = new Ctor(d1);
    e = d.e = getPrecision(xd) - x.e - 1;
    k = e % LOG_BASE;
    d.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k);
    if (maxD == null) {
      maxD = e > 0 ? d : n1;
    } else {
      n = new Ctor(maxD);
      if (!n.isInt() || n.lt(n1))
        throw Error(invalidArgument + n);
      maxD = n.gt(d) ? e > 0 ? d : n1 : n;
    }
    external = false;
    n = new Ctor(digitsToString(xd));
    pr = Ctor.precision;
    Ctor.precision = e = xd.length * LOG_BASE * 2;
    for (; ; ) {
      q = divide(n, d, 0, 1, 1);
      d2 = d0.plus(q.times(d1));
      if (d2.cmp(maxD) == 1)
        break;
      d0 = d1;
      d1 = d2;
      d2 = n1;
      n1 = n0.plus(q.times(d2));
      n0 = d2;
      d2 = d;
      d = n.minus(q.times(d2));
      n = d2;
    }
    d2 = divide(maxD.minus(d0), d1, 0, 1, 1);
    n0 = n0.plus(d2.times(n1));
    d0 = d0.plus(d2.times(d1));
    n0.s = n1.s = x.s;
    r = divide(n1, d1, e, 1).minus(x).abs().cmp(divide(n0, d0, e, 1).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];
    Ctor.precision = pr;
    external = true;
    return r;
  };
  P.toHexadecimal = P.toHex = function(sd, rm) {
    return toStringBinary(this, 16, sd, rm);
  };
  P.toNearest = function(y, rm) {
    var x = this, Ctor = x.constructor;
    x = new Ctor(x);
    if (y == null) {
      if (!x.d)
        return x;
      y = new Ctor(1);
      rm = Ctor.rounding;
    } else {
      y = new Ctor(y);
      if (rm === void 0) {
        rm = Ctor.rounding;
      } else {
        checkInt32(rm, 0, 8);
      }
      if (!x.d)
        return y.s ? x : y;
      if (!y.d) {
        if (y.s)
          y.s = x.s;
        return y;
      }
    }
    if (y.d[0]) {
      external = false;
      x = divide(x, y, 0, rm, 1).times(y);
      external = true;
      finalise(x);
    } else {
      y.s = x.s;
      x = y;
    }
    return x;
  };
  P.toNumber = function() {
    return +this;
  };
  P.toOctal = function(sd, rm) {
    return toStringBinary(this, 8, sd, rm);
  };
  P.toPower = P.pow = function(y) {
    var e, k, pr, r, rm, s, x = this, Ctor = x.constructor, yn = +(y = new Ctor(y));
    if (!x.d || !y.d || !x.d[0] || !y.d[0])
      return new Ctor(mathpow(+x, yn));
    x = new Ctor(x);
    if (x.eq(1))
      return x;
    pr = Ctor.precision;
    rm = Ctor.rounding;
    if (y.eq(1))
      return finalise(x, pr, rm);
    e = mathfloor(y.e / LOG_BASE);
    if (e >= y.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {
      r = intPow(Ctor, x, k, pr);
      return y.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);
    }
    s = x.s;
    if (s < 0) {
      if (e < y.d.length - 1)
        return new Ctor(NaN);
      if ((y.d[e] & 1) == 0)
        s = 1;
      if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {
        x.s = s;
        return x;
      }
    }
    k = mathpow(+x, yn);
    e = k == 0 || !isFinite(k) ? mathfloor(yn * (Math.log("0." + digitsToString(x.d)) / Math.LN10 + x.e + 1)) : new Ctor(k + "").e;
    if (e > Ctor.maxE + 1 || e < Ctor.minE - 1)
      return new Ctor(e > 0 ? s / 0 : 0);
    external = false;
    Ctor.rounding = x.s = 1;
    k = Math.min(12, (e + "").length);
    r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr);
    if (r.d) {
      r = finalise(r, pr + 5, 1);
      if (checkRoundingDigits(r.d, pr, rm)) {
        e = pr + 10;
        r = finalise(naturalExponential(y.times(naturalLogarithm(x, e + k)), e), e + 5, 1);
        if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {
          r = finalise(r, pr + 1, 0);
        }
      }
    }
    r.s = s;
    external = true;
    Ctor.rounding = rm;
    return finalise(r, pr, rm);
  };
  P.toPrecision = function(sd, rm) {
    var str, x = this, Ctor = x.constructor;
    if (sd === void 0) {
      str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
    } else {
      checkInt32(sd, 1, MAX_DIGITS);
      if (rm === void 0)
        rm = Ctor.rounding;
      else
        checkInt32(rm, 0, 8);
      x = finalise(new Ctor(x), sd, rm);
      str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);
    }
    return x.isNeg() && !x.isZero() ? "-" + str : str;
  };
  P.toSignificantDigits = P.toSD = function(sd, rm) {
    var x = this, Ctor = x.constructor;
    if (sd === void 0) {
      sd = Ctor.precision;
      rm = Ctor.rounding;
    } else {
      checkInt32(sd, 1, MAX_DIGITS);
      if (rm === void 0)
        rm = Ctor.rounding;
      else
        checkInt32(rm, 0, 8);
    }
    return finalise(new Ctor(x), sd, rm);
  };
  P.toString = function() {
    var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
    return x.isNeg() && !x.isZero() ? "-" + str : str;
  };
  P.truncated = P.trunc = function() {
    return finalise(new this.constructor(this), this.e + 1, 1);
  };
  P.valueOf = P.toJSON = function() {
    var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
    return x.isNeg() ? "-" + str : str;
  };
  function digitsToString(d) {
    var i, k, ws, indexOfLastWord = d.length - 1, str = "", w = d[0];
    if (indexOfLastWord > 0) {
      str += w;
      for (i = 1; i < indexOfLastWord; i++) {
        ws = d[i] + "";
        k = LOG_BASE - ws.length;
        if (k)
          str += getZeroString(k);
        str += ws;
      }
      w = d[i];
      ws = w + "";
      k = LOG_BASE - ws.length;
      if (k)
        str += getZeroString(k);
    } else if (w === 0) {
      return "0";
    }
    for (; w % 10 === 0; )
      w /= 10;
    return str + w;
  }
  function checkInt32(i, min2, max2) {
    if (i !== ~~i || i < min2 || i > max2) {
      throw Error(invalidArgument + i);
    }
  }
  function checkRoundingDigits(d, i, rm, repeating) {
    var di, k, r, rd;
    for (k = d[0]; k >= 10; k /= 10)
      --i;
    if (--i < 0) {
      i += LOG_BASE;
      di = 0;
    } else {
      di = Math.ceil((i + 1) / LOG_BASE);
      i %= LOG_BASE;
    }
    k = mathpow(10, LOG_BASE - i);
    rd = d[di] % k | 0;
    if (repeating == null) {
      if (i < 3) {
        if (i == 0)
          rd = rd / 100 | 0;
        else if (i == 1)
          rd = rd / 10 | 0;
        r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 5e4 || rd == 0;
      } else {
        r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 100 | 0) == mathpow(10, i - 2) - 1 || (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;
      }
    } else {
      if (i < 4) {
        if (i == 0)
          rd = rd / 1e3 | 0;
        else if (i == 1)
          rd = rd / 100 | 0;
        else if (i == 2)
          rd = rd / 10 | 0;
        r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;
      } else {
        r = ((repeating || rm < 4) && rd + 1 == k || !repeating && rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 1e3 | 0) == mathpow(10, i - 3) - 1;
      }
    }
    return r;
  }
  function convertBase(str, baseIn, baseOut) {
    var j, arr = [0], arrL, i = 0, strL = str.length;
    for (; i < strL; ) {
      for (arrL = arr.length; arrL--; )
        arr[arrL] *= baseIn;
      arr[0] += NUMERALS.indexOf(str.charAt(i++));
      for (j = 0; j < arr.length; j++) {
        if (arr[j] > baseOut - 1) {
          if (arr[j + 1] === void 0)
            arr[j + 1] = 0;
          arr[j + 1] += arr[j] / baseOut | 0;
          arr[j] %= baseOut;
        }
      }
    }
    return arr.reverse();
  }
  function cosine(Ctor, x) {
    var k, len, y;
    if (x.isZero())
      return x;
    len = x.d.length;
    if (len < 32) {
      k = Math.ceil(len / 3);
      y = (1 / tinyPow(4, k)).toString();
    } else {
      k = 16;
      y = "2.3283064365386962890625e-10";
    }
    Ctor.precision += k;
    x = taylorSeries(Ctor, 1, x.times(y), new Ctor(1));
    for (var i = k; i--; ) {
      var cos2x = x.times(x);
      x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);
    }
    Ctor.precision -= k;
    return x;
  }
  var divide = /* @__PURE__ */ function() {
    function multiplyInteger(x, k, base) {
      var temp, carry = 0, i = x.length;
      for (x = x.slice(); i--; ) {
        temp = x[i] * k + carry;
        x[i] = temp % base | 0;
        carry = temp / base | 0;
      }
      if (carry)
        x.unshift(carry);
      return x;
    }
    function compare(a, b, aL, bL) {
      var i, r;
      if (aL != bL) {
        r = aL > bL ? 1 : -1;
      } else {
        for (i = r = 0; i < aL; i++) {
          if (a[i] != b[i]) {
            r = a[i] > b[i] ? 1 : -1;
            break;
          }
        }
      }
      return r;
    }
    function subtract(a, b, aL, base) {
      var i = 0;
      for (; aL--; ) {
        a[aL] -= i;
        i = a[aL] < b[aL] ? 1 : 0;
        a[aL] = i * base + a[aL] - b[aL];
      }
      for (; !a[0] && a.length > 1; )
        a.shift();
    }
    return function(x, y, pr, rm, dp, base) {
      var cmp, e, i, k, logBase, more, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0, yL, yz, Ctor = x.constructor, sign2 = x.s == y.s ? 1 : -1, xd = x.d, yd = y.d;
      if (!xd || !xd[0] || !yd || !yd[0]) {
        return new Ctor(
          // Return NaN if either NaN, or both Infinity or 0.
          !x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN : (
            // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
            xd && xd[0] == 0 || !yd ? sign2 * 0 : sign2 / 0
          )
        );
      }
      if (base) {
        logBase = 1;
        e = x.e - y.e;
      } else {
        base = BASE;
        logBase = LOG_BASE;
        e = mathfloor(x.e / logBase) - mathfloor(y.e / logBase);
      }
      yL = yd.length;
      xL = xd.length;
      q = new Ctor(sign2);
      qd = q.d = [];
      for (i = 0; yd[i] == (xd[i] || 0); i++)
        ;
      if (yd[i] > (xd[i] || 0))
        e--;
      if (pr == null) {
        sd = pr = Ctor.precision;
        rm = Ctor.rounding;
      } else if (dp) {
        sd = pr + (x.e - y.e) + 1;
      } else {
        sd = pr;
      }
      if (sd < 0) {
        qd.push(1);
        more = true;
      } else {
        sd = sd / logBase + 2 | 0;
        i = 0;
        if (yL == 1) {
          k = 0;
          yd = yd[0];
          sd++;
          for (; (i < xL || k) && sd--; i++) {
            t = k * base + (xd[i] || 0);
            qd[i] = t / yd | 0;
            k = t % yd | 0;
          }
          more = k || i < xL;
        } else {
          k = base / (yd[0] + 1) | 0;
          if (k > 1) {
            yd = multiplyInteger(yd, k, base);
            xd = multiplyInteger(xd, k, base);
            yL = yd.length;
            xL = xd.length;
          }
          xi = yL;
          rem = xd.slice(0, yL);
          remL = rem.length;
          for (; remL < yL; )
            rem[remL++] = 0;
          yz = yd.slice();
          yz.unshift(0);
          yd0 = yd[0];
          if (yd[1] >= base / 2)
            ++yd0;
          do {
            k = 0;
            cmp = compare(yd, rem, yL, remL);
            if (cmp < 0) {
              rem0 = rem[0];
              if (yL != remL)
                rem0 = rem0 * base + (rem[1] || 0);
              k = rem0 / yd0 | 0;
              if (k > 1) {
                if (k >= base)
                  k = base - 1;
                prod = multiplyInteger(yd, k, base);
                prodL = prod.length;
                remL = rem.length;
                cmp = compare(prod, rem, prodL, remL);
                if (cmp == 1) {
                  k--;
                  subtract(prod, yL < prodL ? yz : yd, prodL, base);
                }
              } else {
                if (k == 0)
                  cmp = k = 1;
                prod = yd.slice();
              }
              prodL = prod.length;
              if (prodL < remL)
                prod.unshift(0);
              subtract(rem, prod, remL, base);
              if (cmp == -1) {
                remL = rem.length;
                cmp = compare(yd, rem, yL, remL);
                if (cmp < 1) {
                  k++;
                  subtract(rem, yL < remL ? yz : yd, remL, base);
                }
              }
              remL = rem.length;
            } else if (cmp === 0) {
              k++;
              rem = [0];
            }
            qd[i++] = k;
            if (cmp && rem[0]) {
              rem[remL++] = xd[xi] || 0;
            } else {
              rem = [xd[xi]];
              remL = 1;
            }
          } while ((xi++ < xL || rem[0] !== void 0) && sd--);
          more = rem[0] !== void 0;
        }
        if (!qd[0])
          qd.shift();
      }
      if (logBase == 1) {
        q.e = e;
        inexact = more;
      } else {
        for (i = 1, k = qd[0]; k >= 10; k /= 10)
          i++;
        q.e = i + e * logBase - 1;
        finalise(q, dp ? pr + q.e + 1 : pr, rm, more);
      }
      return q;
    };
  }();
  function finalise(x, sd, rm, isTruncated) {
    var digits, i, j, k, rd, roundUp, w, xd, xdi, Ctor = x.constructor;
    out:
      if (sd != null) {
        xd = x.d;
        if (!xd)
          return x;
        for (digits = 1, k = xd[0]; k >= 10; k /= 10)
          digits++;
        i = sd - digits;
        if (i < 0) {
          i += LOG_BASE;
          j = sd;
          w = xd[xdi = 0];
          rd = w / mathpow(10, digits - j - 1) % 10 | 0;
        } else {
          xdi = Math.ceil((i + 1) / LOG_BASE);
          k = xd.length;
          if (xdi >= k) {
            if (isTruncated) {
              for (; k++ <= xdi; )
                xd.push(0);
              w = rd = 0;
              digits = 1;
              i %= LOG_BASE;
              j = i - LOG_BASE + 1;
            } else {
              break out;
            }
          } else {
            w = k = xd[xdi];
            for (digits = 1; k >= 10; k /= 10)
              digits++;
            i %= LOG_BASE;
            j = i - LOG_BASE + digits;
            rd = j < 0 ? 0 : w / mathpow(10, digits - j - 1) % 10 | 0;
          }
        }
        isTruncated = isTruncated || sd < 0 || xd[xdi + 1] !== void 0 || (j < 0 ? w : w % mathpow(10, digits - j - 1));
        roundUp = rm < 4 ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
        (i > 0 ? j > 0 ? w / mathpow(10, digits - j) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
        if (sd < 1 || !xd[0]) {
          xd.length = 0;
          if (roundUp) {
            sd -= x.e + 1;
            xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);
            x.e = -sd || 0;
          } else {
            xd[0] = x.e = 0;
          }
          return x;
        }
        if (i == 0) {
          xd.length = xdi;
          k = 1;
          xdi--;
        } else {
          xd.length = xdi + 1;
          k = mathpow(10, LOG_BASE - i);
          xd[xdi] = j > 0 ? (w / mathpow(10, digits - j) % mathpow(10, j) | 0) * k : 0;
        }
        if (roundUp) {
          for (; ; ) {
            if (xdi == 0) {
              for (i = 1, j = xd[0]; j >= 10; j /= 10)
                i++;
              j = xd[0] += k;
              for (k = 1; j >= 10; j /= 10)
                k++;
              if (i != k) {
                x.e++;
                if (xd[0] == BASE)
                  xd[0] = 1;
              }
              break;
            } else {
              xd[xdi] += k;
              if (xd[xdi] != BASE)
                break;
              xd[xdi--] = 0;
              k = 1;
            }
          }
        }
        for (i = xd.length; xd[--i] === 0; )
          xd.pop();
      }
    if (external) {
      if (x.e > Ctor.maxE) {
        x.d = null;
        x.e = NaN;
      } else if (x.e < Ctor.minE) {
        x.e = 0;
        x.d = [0];
      }
    }
    return x;
  }
  function finiteToString(x, isExp, sd) {
    if (!x.isFinite())
      return nonFiniteToString(x);
    var k, e = x.e, str = digitsToString(x.d), len = str.length;
    if (isExp) {
      if (sd && (k = sd - len) > 0) {
        str = str.charAt(0) + "." + str.slice(1) + getZeroString(k);
      } else if (len > 1) {
        str = str.charAt(0) + "." + str.slice(1);
      }
      str = str + (x.e < 0 ? "e" : "e+") + x.e;
    } else if (e < 0) {
      str = "0." + getZeroString(-e - 1) + str;
      if (sd && (k = sd - len) > 0)
        str += getZeroString(k);
    } else if (e >= len) {
      str += getZeroString(e + 1 - len);
      if (sd && (k = sd - e - 1) > 0)
        str = str + "." + getZeroString(k);
    } else {
      if ((k = e + 1) < len)
        str = str.slice(0, k) + "." + str.slice(k);
      if (sd && (k = sd - len) > 0) {
        if (e + 1 === len)
          str += ".";
        str += getZeroString(k);
      }
    }
    return str;
  }
  function getBase10Exponent(digits, e) {
    var w = digits[0];
    for (e *= LOG_BASE; w >= 10; w /= 10)
      e++;
    return e;
  }
  function getLn10(Ctor, sd, pr) {
    if (sd > LN10_PRECISION) {
      external = true;
      if (pr)
        Ctor.precision = pr;
      throw Error(precisionLimitExceeded);
    }
    return finalise(new Ctor(LN10), sd, 1, true);
  }
  function getPi(Ctor, sd, rm) {
    if (sd > PI_PRECISION)
      throw Error(precisionLimitExceeded);
    return finalise(new Ctor(PI), sd, rm, true);
  }
  function getPrecision(digits) {
    var w = digits.length - 1, len = w * LOG_BASE + 1;
    w = digits[w];
    if (w) {
      for (; w % 10 == 0; w /= 10)
        len--;
      for (w = digits[0]; w >= 10; w /= 10)
        len++;
    }
    return len;
  }
  function getZeroString(k) {
    var zs = "";
    for (; k--; )
      zs += "0";
    return zs;
  }
  function intPow(Ctor, x, n, pr) {
    var isTruncated, r = new Ctor(1), k = Math.ceil(pr / LOG_BASE + 4);
    external = false;
    for (; ; ) {
      if (n % 2) {
        r = r.times(x);
        if (truncate(r.d, k))
          isTruncated = true;
      }
      n = mathfloor(n / 2);
      if (n === 0) {
        n = r.d.length - 1;
        if (isTruncated && r.d[n] === 0)
          ++r.d[n];
        break;
      }
      x = x.times(x);
      truncate(x.d, k);
    }
    external = true;
    return r;
  }
  function isOdd(n) {
    return n.d[n.d.length - 1] & 1;
  }
  function maxOrMin(Ctor, args, n) {
    var k, y, x = new Ctor(args[0]), i = 0;
    for (; ++i < args.length; ) {
      y = new Ctor(args[i]);
      if (!y.s) {
        x = y;
        break;
      }
      k = x.cmp(y);
      if (k === n || k === 0 && x.s === n) {
        x = y;
      }
    }
    return x;
  }
  function naturalExponential(x, sd) {
    var denominator, guard, j, pow2, sum2, t, wpr, rep = 0, i = 0, k = 0, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
    if (!x.d || !x.d[0] || x.e > 17) {
      return new Ctor(x.d ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0 : x.s ? x.s < 0 ? 0 : x : 0 / 0);
    }
    if (sd == null) {
      external = false;
      wpr = pr;
    } else {
      wpr = sd;
    }
    t = new Ctor(0.03125);
    while (x.e > -2) {
      x = x.times(t);
      k += 5;
    }
    guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;
    wpr += guard;
    denominator = pow2 = sum2 = new Ctor(1);
    Ctor.precision = wpr;
    for (; ; ) {
      pow2 = finalise(pow2.times(x), wpr, 1);
      denominator = denominator.times(++i);
      t = sum2.plus(divide(pow2, denominator, wpr, 1));
      if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum2.d).slice(0, wpr)) {
        j = k;
        while (j--)
          sum2 = finalise(sum2.times(sum2), wpr, 1);
        if (sd == null) {
          if (rep < 3 && checkRoundingDigits(sum2.d, wpr - guard, rm, rep)) {
            Ctor.precision = wpr += 10;
            denominator = pow2 = t = new Ctor(1);
            i = 0;
            rep++;
          } else {
            return finalise(sum2, Ctor.precision = pr, rm, external = true);
          }
        } else {
          Ctor.precision = pr;
          return sum2;
        }
      }
      sum2 = t;
    }
  }
  function naturalLogarithm(y, sd) {
    var c, c0, denominator, e, numerator, rep, sum2, t, wpr, x1, x2, n = 1, guard = 10, x = y, xd = x.d, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
    if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {
      return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);
    }
    if (sd == null) {
      external = false;
      wpr = pr;
    } else {
      wpr = sd;
    }
    Ctor.precision = wpr += guard;
    c = digitsToString(xd);
    c0 = c.charAt(0);
    if (Math.abs(e = x.e) < 15e14) {
      while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {
        x = x.times(y);
        c = digitsToString(x.d);
        c0 = c.charAt(0);
        n++;
      }
      e = x.e;
      if (c0 > 1) {
        x = new Ctor("0." + c);
        e++;
      } else {
        x = new Ctor(c0 + "." + c.slice(1));
      }
    } else {
      t = getLn10(Ctor, wpr + 2, pr).times(e + "");
      x = naturalLogarithm(new Ctor(c0 + "." + c.slice(1)), wpr - guard).plus(t);
      Ctor.precision = pr;
      return sd == null ? finalise(x, pr, rm, external = true) : x;
    }
    x1 = x;
    sum2 = numerator = x = divide(x.minus(1), x.plus(1), wpr, 1);
    x2 = finalise(x.times(x), wpr, 1);
    denominator = 3;
    for (; ; ) {
      numerator = finalise(numerator.times(x2), wpr, 1);
      t = sum2.plus(divide(numerator, new Ctor(denominator), wpr, 1));
      if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum2.d).slice(0, wpr)) {
        sum2 = sum2.times(2);
        if (e !== 0)
          sum2 = sum2.plus(getLn10(Ctor, wpr + 2, pr).times(e + ""));
        sum2 = divide(sum2, new Ctor(n), wpr, 1);
        if (sd == null) {
          if (checkRoundingDigits(sum2.d, wpr - guard, rm, rep)) {
            Ctor.precision = wpr += guard;
            t = numerator = x = divide(x1.minus(1), x1.plus(1), wpr, 1);
            x2 = finalise(x.times(x), wpr, 1);
            denominator = rep = 1;
          } else {
            return finalise(sum2, Ctor.precision = pr, rm, external = true);
          }
        } else {
          Ctor.precision = pr;
          return sum2;
        }
      }
      sum2 = t;
      denominator += 2;
    }
  }
  function nonFiniteToString(x) {
    return String(x.s * x.s / 0);
  }
  function parseDecimal(x, str) {
    var e, i, len;
    if ((e = str.indexOf(".")) > -1)
      str = str.replace(".", "");
    if ((i = str.search(/e/i)) > 0) {
      if (e < 0)
        e = i;
      e += +str.slice(i + 1);
      str = str.substring(0, i);
    } else if (e < 0) {
      e = str.length;
    }
    for (i = 0; str.charCodeAt(i) === 48; i++)
      ;
    for (len = str.length; str.charCodeAt(len - 1) === 48; --len)
      ;
    str = str.slice(i, len);
    if (str) {
      len -= i;
      x.e = e = e - i - 1;
      x.d = [];
      i = (e + 1) % LOG_BASE;
      if (e < 0)
        i += LOG_BASE;
      if (i < len) {
        if (i)
          x.d.push(+str.slice(0, i));
        for (len -= LOG_BASE; i < len; )
          x.d.push(+str.slice(i, i += LOG_BASE));
        str = str.slice(i);
        i = LOG_BASE - str.length;
      } else {
        i -= len;
      }
      for (; i--; )
        str += "0";
      x.d.push(+str);
      if (external) {
        if (x.e > x.constructor.maxE) {
          x.d = null;
          x.e = NaN;
        } else if (x.e < x.constructor.minE) {
          x.e = 0;
          x.d = [0];
        }
      }
    } else {
      x.e = 0;
      x.d = [0];
    }
    return x;
  }
  function parseOther(x, str) {
    var base, Ctor, divisor, i, isFloat, len, p, xd, xe;
    if (str.indexOf("_") > -1) {
      str = str.replace(/(\d)_(?=\d)/g, "$1");
      if (isDecimal.test(str))
        return parseDecimal(x, str);
    } else if (str === "Infinity" || str === "NaN") {
      if (!+str)
        x.s = NaN;
      x.e = NaN;
      x.d = null;
      return x;
    }
    if (isHex.test(str)) {
      base = 16;
      str = str.toLowerCase();
    } else if (isBinary.test(str)) {
      base = 2;
    } else if (isOctal.test(str)) {
      base = 8;
    } else {
      throw Error(invalidArgument + str);
    }
    i = str.search(/p/i);
    if (i > 0) {
      p = +str.slice(i + 1);
      str = str.substring(2, i);
    } else {
      str = str.slice(2);
    }
    i = str.indexOf(".");
    isFloat = i >= 0;
    Ctor = x.constructor;
    if (isFloat) {
      str = str.replace(".", "");
      len = str.length;
      i = len - i;
      divisor = intPow(Ctor, new Ctor(base), i, i * 2);
    }
    xd = convertBase(str, base, BASE);
    xe = xd.length - 1;
    for (i = xe; xd[i] === 0; --i)
      xd.pop();
    if (i < 0)
      return new Ctor(x.s * 0);
    x.e = getBase10Exponent(xd, xe);
    x.d = xd;
    external = false;
    if (isFloat)
      x = divide(x, divisor, len * 4);
    if (p)
      x = x.times(Math.abs(p) < 54 ? mathpow(2, p) : Decimal.pow(2, p));
    external = true;
    return x;
  }
  function sine(Ctor, x) {
    var k, len = x.d.length;
    if (len < 3) {
      return x.isZero() ? x : taylorSeries(Ctor, 2, x, x);
    }
    k = 1.4 * Math.sqrt(len);
    k = k > 16 ? 16 : k | 0;
    x = x.times(1 / tinyPow(5, k));
    x = taylorSeries(Ctor, 2, x, x);
    var sin2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
    for (; k--; ) {
      sin2_x = x.times(x);
      x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));
    }
    return x;
  }
  function taylorSeries(Ctor, n, x, y, isHyperbolic) {
    var j, t, u, x2, i = 1, pr = Ctor.precision, k = Math.ceil(pr / LOG_BASE);
    external = false;
    x2 = x.times(x);
    u = new Ctor(y);
    for (; ; ) {
      t = divide(u.times(x2), new Ctor(n++ * n++), pr, 1);
      u = isHyperbolic ? y.plus(t) : y.minus(t);
      y = divide(t.times(x2), new Ctor(n++ * n++), pr, 1);
      t = u.plus(y);
      if (t.d[k] !== void 0) {
        for (j = k; t.d[j] === u.d[j] && j--; )
          ;
        if (j == -1)
          break;
      }
      j = u;
      u = y;
      y = t;
      t = j;
      i++;
    }
    external = true;
    t.d.length = k + 1;
    return t;
  }
  function tinyPow(b, e) {
    var n = b;
    while (--e)
      n *= b;
    return n;
  }
  function toLessThanHalfPi(Ctor, x) {
    var t, isNeg = x.s < 0, pi = getPi(Ctor, Ctor.precision, 1), halfPi = pi.times(0.5);
    x = x.abs();
    if (x.lte(halfPi)) {
      quadrant = isNeg ? 4 : 1;
      return x;
    }
    t = x.divToInt(pi);
    if (t.isZero()) {
      quadrant = isNeg ? 3 : 2;
    } else {
      x = x.minus(t.times(pi));
      if (x.lte(halfPi)) {
        quadrant = isOdd(t) ? isNeg ? 2 : 3 : isNeg ? 4 : 1;
        return x;
      }
      quadrant = isOdd(t) ? isNeg ? 1 : 4 : isNeg ? 3 : 2;
    }
    return x.minus(pi).abs();
  }
  function toStringBinary(x, baseOut, sd, rm) {
    var base, e, i, k, len, roundUp, str, xd, y, Ctor = x.constructor, isExp = sd !== void 0;
    if (isExp) {
      checkInt32(sd, 1, MAX_DIGITS);
      if (rm === void 0)
        rm = Ctor.rounding;
      else
        checkInt32(rm, 0, 8);
    } else {
      sd = Ctor.precision;
      rm = Ctor.rounding;
    }
    if (!x.isFinite()) {
      str = nonFiniteToString(x);
    } else {
      str = finiteToString(x);
      i = str.indexOf(".");
      if (isExp) {
        base = 2;
        if (baseOut == 16) {
          sd = sd * 4 - 3;
        } else if (baseOut == 8) {
          sd = sd * 3 - 2;
        }
      } else {
        base = baseOut;
      }
      if (i >= 0) {
        str = str.replace(".", "");
        y = new Ctor(1);
        y.e = str.length - i;
        y.d = convertBase(finiteToString(y), 10, base);
        y.e = y.d.length;
      }
      xd = convertBase(str, 10, base);
      e = len = xd.length;
      for (; xd[--len] == 0; )
        xd.pop();
      if (!xd[0]) {
        str = isExp ? "0p+0" : "0";
      } else {
        if (i < 0) {
          e--;
        } else {
          x = new Ctor(x);
          x.d = xd;
          x.e = e;
          x = divide(x, y, sd, rm, 0, base);
          xd = x.d;
          e = x.e;
          roundUp = inexact;
        }
        i = xd[sd];
        k = base / 2;
        roundUp = roundUp || xd[sd + 1] !== void 0;
        roundUp = rm < 4 ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2)) : i > k || i === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 || rm === (x.s < 0 ? 8 : 7));
        xd.length = sd;
        if (roundUp) {
          for (; ++xd[--sd] > base - 1; ) {
            xd[sd] = 0;
            if (!sd) {
              ++e;
              xd.unshift(1);
            }
          }
        }
        for (len = xd.length; !xd[len - 1]; --len)
          ;
        for (i = 0, str = ""; i < len; i++)
          str += NUMERALS.charAt(xd[i]);
        if (isExp) {
          if (len > 1) {
            if (baseOut == 16 || baseOut == 8) {
              i = baseOut == 16 ? 4 : 3;
              for (--len; len % i; len++)
                str += "0";
              xd = convertBase(str, base, baseOut);
              for (len = xd.length; !xd[len - 1]; --len)
                ;
              for (i = 1, str = "1."; i < len; i++)
                str += NUMERALS.charAt(xd[i]);
            } else {
              str = str.charAt(0) + "." + str.slice(1);
            }
          }
          str = str + (e < 0 ? "p" : "p+") + e;
        } else if (e < 0) {
          for (; ++e; )
            str = "0" + str;
          str = "0." + str;
        } else {
          if (++e > len)
            for (e -= len; e--; )
              str += "0";
          else if (e < len)
            str = str.slice(0, e) + "." + str.slice(e);
        }
      }
      str = (baseOut == 16 ? "0x" : baseOut == 2 ? "0b" : baseOut == 8 ? "0o" : "") + str;
    }
    return x.s < 0 ? "-" + str : str;
  }
  function truncate(arr, len) {
    if (arr.length > len) {
      arr.length = len;
      return true;
    }
  }
  function abs(x) {
    return new this(x).abs();
  }
  function acos(x) {
    return new this(x).acos();
  }
  function acosh(x) {
    return new this(x).acosh();
  }
  function add(x, y) {
    return new this(x).plus(y);
  }
  function asin(x) {
    return new this(x).asin();
  }
  function asinh(x) {
    return new this(x).asinh();
  }
  function atan(x) {
    return new this(x).atan();
  }
  function atanh(x) {
    return new this(x).atanh();
  }
  function atan2(y, x) {
    y = new this(y);
    x = new this(x);
    var r, pr = this.precision, rm = this.rounding, wpr = pr + 4;
    if (!y.s || !x.s) {
      r = new this(NaN);
    } else if (!y.d && !x.d) {
      r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);
      r.s = y.s;
    } else if (!x.d || y.isZero()) {
      r = x.s < 0 ? getPi(this, pr, rm) : new this(0);
      r.s = y.s;
    } else if (!y.d || x.isZero()) {
      r = getPi(this, wpr, 1).times(0.5);
      r.s = y.s;
    } else if (x.s < 0) {
      this.precision = wpr;
      this.rounding = 1;
      r = this.atan(divide(y, x, wpr, 1));
      x = getPi(this, wpr, 1);
      this.precision = pr;
      this.rounding = rm;
      r = y.s < 0 ? r.minus(x) : r.plus(x);
    } else {
      r = this.atan(divide(y, x, wpr, 1));
    }
    return r;
  }
  function cbrt(x) {
    return new this(x).cbrt();
  }
  function ceil(x) {
    return finalise(x = new this(x), x.e + 1, 2);
  }
  function clamp(x, min2, max2) {
    return new this(x).clamp(min2, max2);
  }
  function config(obj) {
    if (!obj || typeof obj !== "object")
      throw Error(decimalError + "Object expected");
    var i, p, v, useDefaults = obj.defaults === true, ps = [
      "precision",
      1,
      MAX_DIGITS,
      "rounding",
      0,
      8,
      "toExpNeg",
      -EXP_LIMIT,
      0,
      "toExpPos",
      0,
      EXP_LIMIT,
      "maxE",
      0,
      EXP_LIMIT,
      "minE",
      -EXP_LIMIT,
      0,
      "modulo",
      0,
      9
    ];
    for (i = 0; i < ps.length; i += 3) {
      if (p = ps[i], useDefaults)
        this[p] = DEFAULTS[p];
      if ((v = obj[p]) !== void 0) {
        if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2])
          this[p] = v;
        else
          throw Error(invalidArgument + p + ": " + v);
      }
    }
    if (p = "crypto", useDefaults)
      this[p] = DEFAULTS[p];
    if ((v = obj[p]) !== void 0) {
      if (v === true || v === false || v === 0 || v === 1) {
        if (v) {
          if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
            this[p] = true;
          } else {
            throw Error(cryptoUnavailable);
          }
        } else {
          this[p] = false;
        }
      } else {
        throw Error(invalidArgument + p + ": " + v);
      }
    }
    return this;
  }
  function cos(x) {
    return new this(x).cos();
  }
  function cosh(x) {
    return new this(x).cosh();
  }
  function clone(obj) {
    var i, p, ps;
    function Decimal2(v) {
      var e, i2, t, x = this;
      if (!(x instanceof Decimal2))
        return new Decimal2(v);
      x.constructor = Decimal2;
      if (isDecimalInstance(v)) {
        x.s = v.s;
        if (external) {
          if (!v.d || v.e > Decimal2.maxE) {
            x.e = NaN;
            x.d = null;
          } else if (v.e < Decimal2.minE) {
            x.e = 0;
            x.d = [0];
          } else {
            x.e = v.e;
            x.d = v.d.slice();
          }
        } else {
          x.e = v.e;
          x.d = v.d ? v.d.slice() : v.d;
        }
        return;
      }
      t = typeof v;
      if (t === "number") {
        if (v === 0) {
          x.s = 1 / v < 0 ? -1 : 1;
          x.e = 0;
          x.d = [0];
          return;
        }
        if (v < 0) {
          v = -v;
          x.s = -1;
        } else {
          x.s = 1;
        }
        if (v === ~~v && v < 1e7) {
          for (e = 0, i2 = v; i2 >= 10; i2 /= 10)
            e++;
          if (external) {
            if (e > Decimal2.maxE) {
              x.e = NaN;
              x.d = null;
            } else if (e < Decimal2.minE) {
              x.e = 0;
              x.d = [0];
            } else {
              x.e = e;
              x.d = [v];
            }
          } else {
            x.e = e;
            x.d = [v];
          }
          return;
        }
        if (v * 0 !== 0) {
          if (!v)
            x.s = NaN;
          x.e = NaN;
          x.d = null;
          return;
        }
        return parseDecimal(x, v.toString());
      }
      if (t === "string") {
        if ((i2 = v.charCodeAt(0)) === 45) {
          v = v.slice(1);
          x.s = -1;
        } else {
          if (i2 === 43)
            v = v.slice(1);
          x.s = 1;
        }
        return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);
      }
      if (t === "bigint") {
        if (v < 0) {
          v = -v;
          x.s = -1;
        } else {
          x.s = 1;
        }
        return parseDecimal(x, v.toString());
      }
      throw Error(invalidArgument + v);
    }
    Decimal2.prototype = P;
    Decimal2.ROUND_UP = 0;
    Decimal2.ROUND_DOWN = 1;
    Decimal2.ROUND_CEIL = 2;
    Decimal2.ROUND_FLOOR = 3;
    Decimal2.ROUND_HALF_UP = 4;
    Decimal2.ROUND_HALF_DOWN = 5;
    Decimal2.ROUND_HALF_EVEN = 6;
    Decimal2.ROUND_HALF_CEIL = 7;
    Decimal2.ROUND_HALF_FLOOR = 8;
    Decimal2.EUCLID = 9;
    Decimal2.config = Decimal2.set = config;
    Decimal2.clone = clone;
    Decimal2.isDecimal = isDecimalInstance;
    Decimal2.abs = abs;
    Decimal2.acos = acos;
    Decimal2.acosh = acosh;
    Decimal2.add = add;
    Decimal2.asin = asin;
    Decimal2.asinh = asinh;
    Decimal2.atan = atan;
    Decimal2.atanh = atanh;
    Decimal2.atan2 = atan2;
    Decimal2.cbrt = cbrt;
    Decimal2.ceil = ceil;
    Decimal2.clamp = clamp;
    Decimal2.cos = cos;
    Decimal2.cosh = cosh;
    Decimal2.div = div;
    Decimal2.exp = exp;
    Decimal2.floor = floor;
    Decimal2.hypot = hypot;
    Decimal2.ln = ln;
    Decimal2.log = log;
    Decimal2.log10 = log10;
    Decimal2.log2 = log2;
    Decimal2.max = max;
    Decimal2.min = min;
    Decimal2.mod = mod;
    Decimal2.mul = mul;
    Decimal2.pow = pow;
    Decimal2.random = random;
    Decimal2.round = round;
    Decimal2.sign = sign;
    Decimal2.sin = sin;
    Decimal2.sinh = sinh;
    Decimal2.sqrt = sqrt;
    Decimal2.sub = sub;
    Decimal2.sum = sum;
    Decimal2.tan = tan;
    Decimal2.tanh = tanh;
    Decimal2.trunc = trunc;
    if (obj === void 0)
      obj = {};
    if (obj) {
      if (obj.defaults !== true) {
        ps = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"];
        for (i = 0; i < ps.length; )
          if (!obj.hasOwnProperty(p = ps[i++]))
            obj[p] = this[p];
      }
    }
    Decimal2.config(obj);
    return Decimal2;
  }
  function div(x, y) {
    return new this(x).div(y);
  }
  function exp(x) {
    return new this(x).exp();
  }
  function floor(x) {
    return finalise(x = new this(x), x.e + 1, 3);
  }
  function hypot() {
    var i, n, t = new this(0);
    external = false;
    for (i = 0; i < arguments.length; ) {
      n = new this(arguments[i++]);
      if (!n.d) {
        if (n.s) {
          external = true;
          return new this(1 / 0);
        }
        t = n;
      } else if (t.d) {
        t = t.plus(n.times(n));
      }
    }
    external = true;
    return t.sqrt();
  }
  function isDecimalInstance(obj) {
    return obj instanceof Decimal || obj && obj.toStringTag === tag || false;
  }
  function ln(x) {
    return new this(x).ln();
  }
  function log(x, y) {
    return new this(x).log(y);
  }
  function log2(x) {
    return new this(x).log(2);
  }
  function log10(x) {
    return new this(x).log(10);
  }
  function max() {
    return maxOrMin(this, arguments, -1);
  }
  function min() {
    return maxOrMin(this, arguments, 1);
  }
  function mod(x, y) {
    return new this(x).mod(y);
  }
  function mul(x, y) {
    return new this(x).mul(y);
  }
  function pow(x, y) {
    return new this(x).pow(y);
  }
  function random(sd) {
    var d, e, k, n, i = 0, r = new this(1), rd = [];
    if (sd === void 0)
      sd = this.precision;
    else
      checkInt32(sd, 1, MAX_DIGITS);
    k = Math.ceil(sd / LOG_BASE);
    if (!this.crypto) {
      for (; i < k; )
        rd[i++] = Math.random() * 1e7 | 0;
    } else if (crypto.getRandomValues) {
      d = crypto.getRandomValues(new Uint32Array(k));
      for (; i < k; ) {
        n = d[i];
        if (n >= 429e7) {
          d[i] = crypto.getRandomValues(new Uint32Array(1))[0];
        } else {
          rd[i++] = n % 1e7;
        }
      }
    } else if (crypto.randomBytes) {
      d = crypto.randomBytes(k *= 4);
      for (; i < k; ) {
        n = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 127) << 24);
        if (n >= 214e7) {
          crypto.randomBytes(4).copy(d, i);
        } else {
          rd.push(n % 1e7);
          i += 4;
        }
      }
      i = k / 4;
    } else {
      throw Error(cryptoUnavailable);
    }
    k = rd[--i];
    sd %= LOG_BASE;
    if (k && sd) {
      n = mathpow(10, LOG_BASE - sd);
      rd[i] = (k / n | 0) * n;
    }
    for (; rd[i] === 0; i--)
      rd.pop();
    if (i < 0) {
      e = 0;
      rd = [0];
    } else {
      e = -1;
      for (; rd[0] === 0; e -= LOG_BASE)
        rd.shift();
      for (k = 1, n = rd[0]; n >= 10; n /= 10)
        k++;
      if (k < LOG_BASE)
        e -= LOG_BASE - k;
    }
    r.e = e;
    r.d = rd;
    return r;
  }
  function round(x) {
    return finalise(x = new this(x), x.e + 1, this.rounding);
  }
  function sign(x) {
    x = new this(x);
    return x.d ? x.d[0] ? x.s : 0 * x.s : x.s || NaN;
  }
  function sin(x) {
    return new this(x).sin();
  }
  function sinh(x) {
    return new this(x).sinh();
  }
  function sqrt(x) {
    return new this(x).sqrt();
  }
  function sub(x, y) {
    return new this(x).sub(y);
  }
  function sum() {
    var i = 0, args = arguments, x = new this(args[i]);
    external = false;
    for (; x.s && ++i < args.length; )
      x = x.plus(args[i]);
    external = true;
    return finalise(x, this.precision, this.rounding);
  }
  function tan(x) {
    return new this(x).tan();
  }
  function tanh(x) {
    return new this(x).tanh();
  }
  function trunc(x) {
    return finalise(x = new this(x), x.e + 1, 1);
  }
  P[Symbol.for("nodejs.util.inspect.custom")] = P.toString;
  P[Symbol.toStringTag] = "Decimal";
  var Decimal = P.constructor = clone(DEFAULTS);
  LN10 = new Decimal(LN10);
  PI = new Decimal(PI);

  // node_modules/.aspect_rules_js/@formatjs+ecma402-abstract@0.0.0/node_modules/@formatjs/ecma402-abstract/constants.js
  var TEN = new Decimal(10);
  var ZERO = new Decimal(0);
  var NEGATIVE_ZERO = new Decimal(-0);

  // node_modules/.aspect_rules_js/@formatjs+fast-memoize@0.0.0/node_modules/@formatjs/fast-memoize/index.js
  function memoize(fn, options) {
    const cache = options && options.cache ? options.cache : cacheDefault;
    const serializer = options && options.serializer ? options.serializer : serializerDefault;
    const strategy = options && options.strategy ? options.strategy : strategyDefault;
    return strategy(fn, {
      cache,
      serializer
    });
  }
  function isPrimitive(value) {
    return value == null || typeof value === "number" || typeof value === "boolean";
  }
  function monadic(fn, cache, serializer, arg) {
    const cacheKey = isPrimitive(arg) ? arg : serializer(arg);
    let computedValue = cache.get(cacheKey);
    if (typeof computedValue === "undefined") {
      computedValue = fn.call(this, arg);
      cache.set(cacheKey, computedValue);
    }
    return computedValue;
  }
  function variadic(fn, cache, serializer) {
    const args = Array.prototype.slice.call(arguments, 3);
    const cacheKey = serializer(args);
    let computedValue = cache.get(cacheKey);
    if (typeof computedValue === "undefined") {
      computedValue = fn.apply(this, args);
      cache.set(cacheKey, computedValue);
    }
    return computedValue;
  }
  function assemble(fn, context, strategy, cache, serialize) {
    return strategy.bind(context, fn, cache, serialize);
  }
  function strategyDefault(fn, options) {
    const strategy = fn.length === 1 ? monadic : variadic;
    return assemble(fn, this, strategy, options.cache.create(), options.serializer);
  }
  function strategyVariadic(fn, options) {
    return assemble(fn, this, variadic, options.cache.create(), options.serializer);
  }
  function strategyMonadic(fn, options) {
    return assemble(fn, this, monadic, options.cache.create(), options.serializer);
  }
  var serializerDefault = function() {
    return JSON.stringify(arguments);
  };
  var ObjectWithoutPrototypeCache = class {
    constructor() {
      __publicField(this, "cache");
      this.cache = /* @__PURE__ */ Object.create(null);
    }
    get(key) {
      return this.cache[key];
    }
    set(key, value) {
      this.cache[key] = value;
    }
  };
  var cacheDefault = { create: function create() {
    return new ObjectWithoutPrototypeCache();
  } };
  var strategies = {
    variadic: strategyVariadic,
    monadic: strategyMonadic
  };

  // node_modules/.aspect_rules_js/@formatjs+ecma402-abstract@0.0.0/node_modules/@formatjs/ecma402-abstract/utils.js
  var createMemoizedNumberFormat = memoize((...args) => new Intl.NumberFormat(...args), { strategy: strategies.variadic });
  var createMemoizedDateTimeFormat = memoize((...args) => new Intl.DateTimeFormat(...args), { strategy: strategies.variadic });
  var createMemoizedPluralRules = memoize((...args) => new Intl.PluralRules(...args), { strategy: strategies.variadic });
  var createMemoizedLocale = memoize((...args) => new Intl.Locale(...args), { strategy: strategies.variadic });
  var createMemoizedListFormat = memoize((...args) => new Intl.ListFormat(...args), { strategy: strategies.variadic });

  // node_modules/.aspect_rules_js/@formatjs+ecma402-abstract@0.0.0/node_modules/@formatjs/ecma402-abstract/262.js
  var MINUTES_PER_HOUR = 60;
  var SECONDS_PER_MINUTE = 60;
  var MS_PER_SECOND = 1e3;
  var MS_PER_MINUTE = MS_PER_SECOND * SECONDS_PER_MINUTE;
  var MS_PER_HOUR = MS_PER_MINUTE * MINUTES_PER_HOUR;

  // node_modules/.aspect_rules_js/@formatjs+ecma402-abstract@0.0.0/node_modules/@formatjs/ecma402-abstract/IsSanctionedSimpleUnitIdentifier.js
  var SANCTIONED_UNITS = [
    "angle-degree",
    "area-acre",
    "area-hectare",
    "concentr-percent",
    "digital-bit",
    "digital-byte",
    "digital-gigabit",
    "digital-gigabyte",
    "digital-kilobit",
    "digital-kilobyte",
    "digital-megabit",
    "digital-megabyte",
    "digital-petabyte",
    "digital-terabit",
    "digital-terabyte",
    "duration-day",
    "duration-hour",
    "duration-millisecond",
    "duration-minute",
    "duration-month",
    "duration-second",
    "duration-week",
    "duration-year",
    "length-centimeter",
    "length-foot",
    "length-inch",
    "length-kilometer",
    "length-meter",
    "length-mile-scandinavian",
    "length-mile",
    "length-millimeter",
    "length-yard",
    "mass-gram",
    "mass-kilogram",
    "mass-ounce",
    "mass-pound",
    "mass-stone",
    "temperature-celsius",
    "temperature-fahrenheit",
    "volume-fluid-ounce",
    "volume-gallon",
    "volume-liter",
    "volume-milliliter"
  ];
  function removeUnitNamespace(unit) {
    return unit.slice(unit.indexOf("-") + 1);
  }
  var SIMPLE_UNITS = SANCTIONED_UNITS.map(removeUnitNamespace);

  // node_modules/.aspect_rules_js/@formatjs+ecma402-abstract@0.0.0/node_modules/@formatjs/ecma402-abstract/NumberFormat/decimal-cache.js
  var getPowerOf10 = memoize((exponent) => {
    return Decimal.pow(10, exponent);
  });

  // node_modules/.aspect_rules_js/@formatjs+ecma402-abstract@0.0.0/node_modules/@formatjs/ecma402-abstract/NumberFormat/ComputeExponentForMagnitude.js
  Decimal.set({ toExpPos: 100 });

  // node_modules/.aspect_rules_js/@formatjs+ecma402-abstract@0.0.0/node_modules/@formatjs/ecma402-abstract/NumberFormat/ToRawFixed.js
  Decimal.set({ toExpPos: 100 });

  // node_modules/.aspect_rules_js/@formatjs+ecma402-abstract@0.0.0/node_modules/@formatjs/ecma402-abstract/regex.generated.js
  var S_UNICODE_REGEX = /[\$\+<->\^`\|~\xA2-\xA6\xA8\xA9\xAC\xAE-\xB1\xB4\xB8\xD7\xF7\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0384\u0385\u03F6\u0482\u058D-\u058F\u0606-\u0608\u060B\u060E\u060F\u06DE\u06E9\u06FD\u06FE\u07F6\u07FE\u07FF\u09F2\u09F3\u09FA\u09FB\u0AF1\u0B70\u0BF3-\u0BFA\u0C7F\u0D4F\u0D79\u0E3F\u0F01-\u0F03\u0F13\u0F15-\u0F17\u0F1A-\u0F1F\u0F34\u0F36\u0F38\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE\u0FCF\u0FD5-\u0FD8\u109E\u109F\u1390-\u1399\u166D\u17DB\u1940\u19DE-\u19FF\u1B61-\u1B6A\u1B74-\u1B7C\u1FBD\u1FBF-\u1FC1\u1FCD-\u1FCF\u1FDD-\u1FDF\u1FED-\u1FEF\u1FFD\u1FFE\u2044\u2052\u207A-\u207C\u208A-\u208C\u20A0-\u20BF\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u214F\u218A\u218B\u2190-\u2307\u230C-\u2328\u232B-\u2426\u2440-\u244A\u249C-\u24E9\u2500-\u2767\u2794-\u27C4\u27C7-\u27E5\u27F0-\u2982\u2999-\u29D7\u29DC-\u29FB\u29FE-\u2B73\u2B76-\u2B95\u2B97-\u2BFF\u2CE5-\u2CEA\u2E50\u2E51\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3004\u3012\u3013\u3020\u3036\u3037\u303E\u303F\u309B\u309C\u3190\u3191\u3196-\u319F\u31C0-\u31E3\u3200-\u321E\u322A-\u3247\u3250\u3260-\u327F\u328A-\u32B0\u32C0-\u33FF\u4DC0-\u4DFF\uA490-\uA4C6\uA700-\uA716\uA720\uA721\uA789\uA78A\uA828-\uA82B\uA836-\uA839\uAA77-\uAA79\uAB5B\uAB6A\uAB6B\uFB29\uFBB2-\uFBC1\uFDFC\uFDFD\uFE62\uFE64-\uFE66\uFE69\uFF04\uFF0B\uFF1C-\uFF1E\uFF3E\uFF40\uFF5C\uFF5E\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFFC\uFFFD]|\uD800[\uDD37-\uDD3F\uDD79-\uDD89\uDD8C-\uDD8E\uDD90-\uDD9C\uDDA0\uDDD0-\uDDFC]|\uD802[\uDC77\uDC78\uDEC8]|\uD805\uDF3F|\uD807[\uDFD5-\uDFF1]|\uD81A[\uDF3C-\uDF3F\uDF45]|\uD82F\uDC9C|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD64\uDD6A-\uDD6C\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDE8\uDE00-\uDE41\uDE45\uDF00-\uDF56]|\uD835[\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85\uDE86]|\uD838[\uDD4F\uDEFF]|\uD83B[\uDCAC\uDCB0\uDD2E\uDEF0\uDEF1]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD0D-\uDDAD\uDDE6-\uDE02\uDE10-\uDE3B\uDE40-\uDE48\uDE50\uDE51\uDE60-\uDE65\uDF00-\uDFFF]|\uD83D[\uDC00-\uDED7\uDEE0-\uDEEC\uDEF0-\uDEFC\uDF00-\uDF73\uDF80-\uDFD8\uDFE0-\uDFEB]|\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDCB0\uDCB1\uDD00-\uDD78\uDD7A-\uDDCB\uDDCD-\uDE53\uDE60-\uDE6D\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6\uDF00-\uDF92\uDF94-\uDFCA]/;

  // node_modules/.aspect_rules_js/@formatjs+ecma402-abstract@0.0.0/node_modules/@formatjs/ecma402-abstract/NumberFormat/format_to_parts.js
  var CARET_S_UNICODE_REGEX = new RegExp(`^${S_UNICODE_REGEX.source}`);
  var S_DOLLAR_UNICODE_REGEX = new RegExp(`${S_UNICODE_REGEX.source}$`);

  // node_modules/.aspect_rules_js/@formatjs+intl-localematcher@0.0.0/node_modules/@formatjs/intl-localematcher/abstract/languageMatching.js
  var data = { supplemental: { languageMatching: { "written-new": [
    { paradigmLocales: { _locales: "en en_GB es es_419 pt_BR pt_PT" } },
    { $enUS: { _value: "AS+CA+GU+MH+MP+PH+PR+UM+US+VI" } },
    { $cnsar: { _value: "HK+MO" } },
    { $americas: { _value: "019" } },
    { $maghreb: { _value: "MA+DZ+TN+LY+MR+EH" } },
    { no: {
      _desired: "nb",
      _distance: "1"
    } },
    { bs: {
      _desired: "hr",
      _distance: "4"
    } },
    { bs: {
      _desired: "sh",
      _distance: "4"
    } },
    { hr: {
      _desired: "sh",
      _distance: "4"
    } },
    { sr: {
      _desired: "sh",
      _distance: "4"
    } },
    { aa: {
      _desired: "ssy",
      _distance: "4"
    } },
    { de: {
      _desired: "gsw",
      _distance: "4",
      _oneway: "true"
    } },
    { de: {
      _desired: "lb",
      _distance: "4",
      _oneway: "true"
    } },
    { no: {
      _desired: "da",
      _distance: "8"
    } },
    { nb: {
      _desired: "da",
      _distance: "8"
    } },
    { ru: {
      _desired: "ab",
      _distance: "30",
      _oneway: "true"
    } },
    { en: {
      _desired: "ach",
      _distance: "30",
      _oneway: "true"
    } },
    { nl: {
      _desired: "af",
      _distance: "20",
      _oneway: "true"
    } },
    { en: {
      _desired: "ak",
      _distance: "30",
      _oneway: "true"
    } },
    { en: {
      _desired: "am",
      _distance: "30",
      _oneway: "true"
    } },
    { es: {
      _desired: "ay",
      _distance: "20",
      _oneway: "true"
    } },
    { ru: {
      _desired: "az",
      _distance: "30",
      _oneway: "true"
    } },
    { ur: {
      _desired: "bal",
      _distance: "20",
      _oneway: "true"
    } },
    { ru: {
      _desired: "be",
      _distance: "20",
      _oneway: "true"
    } },
    { en: {
      _desired: "bem",
      _distance: "30",
      _oneway: "true"
    } },
    { hi: {
      _desired: "bh",
      _distance: "30",
      _oneway: "true"
    } },
    { en: {
      _desired: "bn",
      _distance: "30",
      _oneway: "true"
    } },
    { zh: {
      _desired: "bo",
      _distance: "20",
      _oneway: "true"
    } },
    { fr: {
      _desired: "br",
      _distance: "20",
      _oneway: "true"
    } },
    { es: {
      _desired: "ca",
      _distance: "20",
      _oneway: "true"
    } },
    { fil: {
      _desired: "ceb",
      _distance: "30",
      _oneway: "true"
    } },
    { en: {
      _desired: "chr",
      _distance: "20",
      _oneway: "true"
    } },
    { ar: {
      _desired: "ckb",
      _distance: "30",
      _oneway: "true"
    } },
    { fr: {
      _desired: "co",
      _distance: "20",
      _oneway: "true"
    } },
    { fr: {
      _desired: "crs",
      _distance: "20",
      _oneway: "true"
    } },
    { sk: {
      _desired: "cs",
      _distance: "20"
    } },
    { en: {
      _desired: "cy",
      _distance: "20",
      _oneway: "true"
    } },
    { en: {
      _desired: "ee",
      _distance: "30",
      _oneway: "true"
    } },
    { en: {
      _desired: "eo",
      _distance: "30",
      _oneway: "true"
    } },
    { es: {
      _desired: "eu",
      _distance: "20",
      _oneway: "true"
    } },
    { da: {
      _desired: "fo",
      _distance: "20",
      _oneway: "true"
    } },
    { nl: {
      _desired: "fy",
      _distance: "20",
      _oneway: "true"
    } },
    { en: {
      _desired: "ga",
      _distance: "20",
      _oneway: "true"
    } },
    { en: {
      _desired: "gaa",
      _distance: "30",
      _oneway: "true"
    } },
    { en: {
      _desired: "gd",
      _distance: "20",
      _oneway: "true"
    } },
    { es: {
      _desired: "gl",
      _distance: "20",
      _oneway: "true"
    } },
    { es: {
      _desired: "gn",
      _distance: "20",
      _oneway: "true"
    } },
    { hi: {
      _desired: "gu",
      _distance: "30",
      _oneway: "true"
    } },
    { en: {
      _desired: "ha",
      _distance: "30",
      _oneway: "true"
    } },
    { en: {
      _desired: "haw",
      _distance: "20",
      _oneway: "true"
    } },
    { fr: {
      _desired: "ht",
      _distance: "20",
      _oneway: "true"
    } },
    { ru: {
      _desired: "hy",
      _distance: "30",
      _oneway: "true"
    } },
    { en: {
      _desired: "ia",
      _distance: "30",
      _oneway: "true"
    } },
    { en: {
      _desired: "ig",
      _distance: "30",
      _oneway: "true"
    } },
    { en: {
      _desired: "is",
      _distance: "20",
      _oneway: "true"
    } },
    { id: {
      _desired: "jv",
      _distance: "20",
      _oneway: "true"
    } },
    { en: {
      _desired: "ka",
      _distance: "30",
      _oneway: "true"
    } },
    { fr: {
      _desired: "kg",
      _distance: "30",
      _oneway: "true"
    } },
    { ru: {
      _desired: "kk",
      _distance: "30",
      _oneway: "true"
    } },
    { en: {
      _desired: "km",
      _distance: "30",
      _oneway: "true"
    } },
    { en: {
      _desired: "kn",
      _distance: "30",
      _oneway: "true"
    } },
    { en: {
      _desired: "kri",
      _distance: "30",
      _oneway: "true"
    } },
    { tr: {
      _desired: "ku",
      _distance: "30",
      _oneway: "true"
    } },
    { ru: {
      _desired: "ky",
      _distance: "30",
      _oneway: "true"
    } },
    { it: {
      _desired: "la",
      _distance: "20",
      _oneway: "true"
    } },
    { en: {
      _desired: "lg",
      _distance: "30",
      _oneway: "true"
    } },
    { fr: {
      _desired: "ln",
      _distance: "30",
      _oneway: "true"
    } },
    { en: {
      _desired: "lo",
      _distance: "30",
      _oneway: "true"
    } },
    { en: {
      _desired: "loz",
      _distance: "30",
      _oneway: "true"
    } },
    { fr: {
      _desired: "lua",
      _distance: "30",
      _oneway: "true"
    } },
    { hi: {
      _desired: "mai",
      _distance: "20",
      _oneway: "true"
    } },
    { en: {
      _desired: "mfe",
      _distance: "30",
      _oneway: "true"
    } },
    { fr: {
      _desired: "mg",
      _distance: "30",
      _oneway: "true"
    } },
    { en: {
      _desired: "mi",
      _distance: "20",
      _oneway: "true"
    } },
    { en: {
      _desired: "ml",
      _distance: "30",
      _oneway: "true"
    } },
    { ru: {
      _desired: "mn",
      _distance: "30",
      _oneway: "true"
    } },
    { hi: {
      _desired: "mr",
      _distance: "30",
      _oneway: "true"
    } },
    { id: {
      _desired: "ms",
      _distance: "30",
      _oneway: "true"
    } },
    { en: {
      _desired: "mt",
      _distance: "30",
      _oneway: "true"
    } },
    { en: {
      _desired: "my",
      _distance: "30",
      _oneway: "true"
    } },
    { en: {
      _desired: "ne",
      _distance: "30",
      _oneway: "true"
    } },
    { nb: {
      _desired: "nn",
      _distance: "20"
    } },
    { no: {
      _desired: "nn",
      _distance: "20"
    } },
    { en: {
      _desired: "nso",
      _distance: "30",
      _oneway: "true"
    } },
    { en: {
      _desired: "ny",
      _distance: "30",
      _oneway: "true"
    } },
    { en: {
      _desired: "nyn",
      _distance: "30",
      _oneway: "true"
    } },
    { fr: {
      _desired: "oc",
      _distance: "20",
      _oneway: "true"
    } },
    { en: {
      _desired: "om",
      _distance: "30",
      _oneway: "true"
    } },
    { en: {
      _desired: "or",
      _distance: "30",
      _oneway: "true"
    } },
    { en: {
      _desired: "pa",
      _distance: "30",
      _oneway: "true"
    } },
    { en: {
      _desired: "pcm",
      _distance: "20",
      _oneway: "true"
    } },
    { en: {
      _desired: "ps",
      _distance: "30",
      _oneway: "true"
    } },
    { es: {
      _desired: "qu",
      _distance: "30",
      _oneway: "true"
    } },
    { de: {
      _desired: "rm",
      _distance: "20",
      _oneway: "true"
    } },
    { en: {
      _desired: "rn",
      _distance: "30",
      _oneway: "true"
    } },
    { fr: {
      _desired: "rw",
      _distance: "30",
      _oneway: "true"
    } },
    { hi: {
      _desired: "sa",
      _distance: "30",
      _oneway: "true"
    } },
    { en: {
      _desired: "sd",
      _distance: "30",
      _oneway: "true"
    } },
    { en: {
      _desired: "si",
      _distance: "30",
      _oneway: "true"
    } },
    { en: {
      _desired: "sn",
      _distance: "30",
      _oneway: "true"
    } },
    { en: {
      _desired: "so",
      _distance: "30",
      _oneway: "true"
    } },
    { en: {
      _desired: "sq",
      _distance: "30",
      _oneway: "true"
    } },
    { en: {
      _desired: "st",
      _distance: "30",
      _oneway: "true"
    } },
    { id: {
      _desired: "su",
      _distance: "20",
      _oneway: "true"
    } },
    { en: {
      _desired: "sw",
      _distance: "30",
      _oneway: "true"
    } },
    { en: {
      _desired: "ta",
      _distance: "30",
      _oneway: "true"
    } },
    { en: {
      _desired: "te",
      _distance: "30",
      _oneway: "true"
    } },
    { ru: {
      _desired: "tg",
      _distance: "30",
      _oneway: "true"
    } },
    { en: {
      _desired: "ti",
      _distance: "30",
      _oneway: "true"
    } },
    { ru: {
      _desired: "tk",
      _distance: "30",
      _oneway: "true"
    } },
    { en: {
      _desired: "tlh",
      _distance: "30",
      _oneway: "true"
    } },
    { en: {
      _desired: "tn",
      _distance: "30",
      _oneway: "true"
    } },
    { en: {
      _desired: "to",
      _distance: "30",
      _oneway: "true"
    } },
    { ru: {
      _desired: "tt",
      _distance: "30",
      _oneway: "true"
    } },
    { en: {
      _desired: "tum",
      _distance: "30",
      _oneway: "true"
    } },
    { zh: {
      _desired: "ug",
      _distance: "20",
      _oneway: "true"
    } },
    { ru: {
      _desired: "uk",
      _distance: "20",
      _oneway: "true"
    } },
    { en: {
      _desired: "ur",
      _distance: "30",
      _oneway: "true"
    } },
    { ru: {
      _desired: "uz",
      _distance: "30",
      _oneway: "true"
    } },
    { fr: {
      _desired: "wo",
      _distance: "30",
      _oneway: "true"
    } },
    { en: {
      _desired: "xh",
      _distance: "30",
      _oneway: "true"
    } },
    { en: {
      _desired: "yi",
      _distance: "30",
      _oneway: "true"
    } },
    { en: {
      _desired: "yo",
      _distance: "30",
      _oneway: "true"
    } },
    { zh: {
      _desired: "za",
      _distance: "20",
      _oneway: "true"
    } },
    { en: {
      _desired: "zu",
      _distance: "30",
      _oneway: "true"
    } },
    { ar: {
      _desired: "aao",
      _distance: "10",
      _oneway: "true"
    } },
    { ar: {
      _desired: "abh",
      _distance: "10",
      _oneway: "true"
    } },
    { ar: {
      _desired: "abv",
      _distance: "10",
      _oneway: "true"
    } },
    { ar: {
      _desired: "acm",
      _distance: "10",
      _oneway: "true"
    } },
    { ar: {
      _desired: "acq",
      _distance: "10",
      _oneway: "true"
    } },
    { ar: {
      _desired: "acw",
      _distance: "10",
      _oneway: "true"
    } },
    { ar: {
      _desired: "acx",
      _distance: "10",
      _oneway: "true"
    } },
    { ar: {
      _desired: "acy",
      _distance: "10",
      _oneway: "true"
    } },
    { ar: {
      _desired: "adf",
      _distance: "10",
      _oneway: "true"
    } },
    { ar: {
      _desired: "aeb",
      _distance: "10",
      _oneway: "true"
    } },
    { ar: {
      _desired: "aec",
      _distance: "10",
      _oneway: "true"
    } },
    { ar: {
      _desired: "afb",
      _distance: "10",
      _oneway: "true"
    } },
    { ar: {
      _desired: "ajp",
      _distance: "10",
      _oneway: "true"
    } },
    { ar: {
      _desired: "apc",
      _distance: "10",
      _oneway: "true"
    } },
    { ar: {
      _desired: "apd",
      _distance: "10",
      _oneway: "true"
    } },
    { ar: {
      _desired: "arq",
      _distance: "10",
      _oneway: "true"
    } },
    { ar: {
      _desired: "ars",
      _distance: "10",
      _oneway: "true"
    } },
    { ar: {
      _desired: "ary",
      _distance: "10",
      _oneway: "true"
    } },
    { ar: {
      _desired: "arz",
      _distance: "10",
      _oneway: "true"
    } },
    { ar: {
      _desired: "auz",
      _distance: "10",
      _oneway: "true"
    } },
    { ar: {
      _desired: "avl",
      _distance: "10",
      _oneway: "true"
    } },
    { ar: {
      _desired: "ayh",
      _distance: "10",
      _oneway: "true"
    } },
    { ar: {
      _desired: "ayl",
      _distance: "10",
      _oneway: "true"
    } },
    { ar: {
      _desired: "ayn",
      _distance: "10",
      _oneway: "true"
    } },
    { ar: {
      _desired: "ayp",
      _distance: "10",
      _oneway: "true"
    } },
    { ar: {
      _desired: "bbz",
      _distance: "10",
      _oneway: "true"
    } },
    { ar: {
      _desired: "pga",
      _distance: "10",
      _oneway: "true"
    } },
    { ar: {
      _desired: "shu",
      _distance: "10",
      _oneway: "true"
    } },
    { ar: {
      _desired: "ssh",
      _distance: "10",
      _oneway: "true"
    } },
    { az: {
      _desired: "azb",
      _distance: "10",
      _oneway: "true"
    } },
    { et: {
      _desired: "vro",
      _distance: "10",
      _oneway: "true"
    } },
    { ff: {
      _desired: "ffm",
      _distance: "10",
      _oneway: "true"
    } },
    { ff: {
      _desired: "fub",
      _distance: "10",
      _oneway: "true"
    } },
    { ff: {
      _desired: "fue",
      _distance: "10",
      _oneway: "true"
    } },
    { ff: {
      _desired: "fuf",
      _distance: "10",
      _oneway: "true"
    } },
    { ff: {
      _desired: "fuh",
      _distance: "10",
      _oneway: "true"
    } },
    { ff: {
      _desired: "fui",
      _distance: "10",
      _oneway: "true"
    } },
    { ff: {
      _desired: "fuq",
      _distance: "10",
      _oneway: "true"
    } },
    { ff: {
      _desired: "fuv",
      _distance: "10",
      _oneway: "true"
    } },
    { gn: {
      _desired: "gnw",
      _distance: "10",
      _oneway: "true"
    } },
    { gn: {
      _desired: "gui",
      _distance: "10",
      _oneway: "true"
    } },
    { gn: {
      _desired: "gun",
      _distance: "10",
      _oneway: "true"
    } },
    { gn: {
      _desired: "nhd",
      _distance: "10",
      _oneway: "true"
    } },
    { iu: {
      _desired: "ikt",
      _distance: "10",
      _oneway: "true"
    } },
    { kln: {
      _desired: "enb",
      _distance: "10",
      _oneway: "true"
    } },
    { kln: {
      _desired: "eyo",
      _distance: "10",
      _oneway: "true"
    } },
    { kln: {
      _desired: "niq",
      _distance: "10",
      _oneway: "true"
    } },
    { kln: {
      _desired: "oki",
      _distance: "10",
      _oneway: "true"
    } },
    { kln: {
      _desired: "pko",
      _distance: "10",
      _oneway: "true"
    } },
    { kln: {
      _desired: "sgc",
      _distance: "10",
      _oneway: "true"
    } },
    { kln: {
      _desired: "tec",
      _distance: "10",
      _oneway: "true"
    } },
    { kln: {
      _desired: "tuy",
      _distance: "10",
      _oneway: "true"
    } },
    { kok: {
      _desired: "gom",
      _distance: "10",
      _oneway: "true"
    } },
    { kpe: {
      _desired: "gkp",
      _distance: "10",
      _oneway: "true"
    } },
    { luy: {
      _desired: "ida",
      _distance: "10",
      _oneway: "true"
    } },
    { luy: {
      _desired: "lkb",
      _distance: "10",
      _oneway: "true"
    } },
    { luy: {
      _desired: "lko",
      _distance: "10",
      _oneway: "true"
    } },
    { luy: {
      _desired: "lks",
      _distance: "10",
      _oneway: "true"
    } },
    { luy: {
      _desired: "lri",
      _distance: "10",
      _oneway: "true"
    } },
    { luy: {
      _desired: "lrm",
      _distance: "10",
      _oneway: "true"
    } },
    { luy: {
      _desired: "lsm",
      _distance: "10",
      _oneway: "true"
    } },
    { luy: {
      _desired: "lto",
      _distance: "10",
      _oneway: "true"
    } },
    { luy: {
      _desired: "lts",
      _distance: "10",
      _oneway: "true"
    } },
    { luy: {
      _desired: "lwg",
      _distance: "10",
      _oneway: "true"
    } },
    { luy: {
      _desired: "nle",
      _distance: "10",
      _oneway: "true"
    } },
    { luy: {
      _desired: "nyd",
      _distance: "10",
      _oneway: "true"
    } },
    { luy: {
      _desired: "rag",
      _distance: "10",
      _oneway: "true"
    } },
    { lv: {
      _desired: "ltg",
      _distance: "10",
      _oneway: "true"
    } },
    { mg: {
      _desired: "bhr",
      _distance: "10",
      _oneway: "true"
    } },
    { mg: {
      _desired: "bjq",
      _distance: "10",
      _oneway: "true"
    } },
    { mg: {
      _desired: "bmm",
      _distance: "10",
      _oneway: "true"
    } },
    { mg: {
      _desired: "bzc",
      _distance: "10",
      _oneway: "true"
    } },
    { mg: {
      _desired: "msh",
      _distance: "10",
      _oneway: "true"
    } },
    { mg: {
      _desired: "skg",
      _distance: "10",
      _oneway: "true"
    } },
    { mg: {
      _desired: "tdx",
      _distance: "10",
      _oneway: "true"
    } },
    { mg: {
      _desired: "tkg",
      _distance: "10",
      _oneway: "true"
    } },
    { mg: {
      _desired: "txy",
      _distance: "10",
      _oneway: "true"
    } },
    { mg: {
      _desired: "xmv",
      _distance: "10",
      _oneway: "true"
    } },
    { mg: {
      _desired: "xmw",
      _distance: "10",
      _oneway: "true"
    } },
    { mn: {
      _desired: "mvf",
      _distance: "10",
      _oneway: "true"
    } },
    { ms: {
      _desired: "bjn",
      _distance: "10",
      _oneway: "true"
    } },
    { ms: {
      _desired: "btj",
      _distance: "10",
      _oneway: "true"
    } },
    { ms: {
      _desired: "bve",
      _distance: "10",
      _oneway: "true"
    } },
    { ms: {
      _desired: "bvu",
      _distance: "10",
      _oneway: "true"
    } },
    { ms: {
      _desired: "coa",
      _distance: "10",
      _oneway: "true"
    } },
    { ms: {
      _desired: "dup",
      _distance: "10",
      _oneway: "true"
    } },
    { ms: {
      _desired: "hji",
      _distance: "10",
      _oneway: "true"
    } },
    { ms: {
      _desired: "id",
      _distance: "10",
      _oneway: "true"
    } },
    { ms: {
      _desired: "jak",
      _distance: "10",
      _oneway: "true"
    } },
    { ms: {
      _desired: "jax",
      _distance: "10",
      _oneway: "true"
    } },
    { ms: {
      _desired: "kvb",
      _distance: "10",
      _oneway: "true"
    } },
    { ms: {
      _desired: "kvr",
      _distance: "10",
      _oneway: "true"
    } },
    { ms: {
      _desired: "kxd",
      _distance: "10",
      _oneway: "true"
    } },
    { ms: {
      _desired: "lce",
      _distance: "10",
      _oneway: "true"
    } },
    { ms: {
      _desired: "lcf",
      _distance: "10",
      _oneway: "true"
    } },
    { ms: {
      _desired: "liw",
      _distance: "10",
      _oneway: "true"
    } },
    { ms: {
      _desired: "max",
      _distance: "10",
      _oneway: "true"
    } },
    { ms: {
      _desired: "meo",
      _distance: "10",
      _oneway: "true"
    } },
    { ms: {
      _desired: "mfa",
      _distance: "10",
      _oneway: "true"
    } },
    { ms: {
      _desired: "mfb",
      _distance: "10",
      _oneway: "true"
    } },
    { ms: {
      _desired: "min",
      _distance: "10",
      _oneway: "true"
    } },
    { ms: {
      _desired: "mqg",
      _distance: "10",
      _oneway: "true"
    } },
    { ms: {
      _desired: "msi",
      _distance: "10",
      _oneway: "true"
    } },
    { ms: {
      _desired: "mui",
      _distance: "10",
      _oneway: "true"
    } },
    { ms: {
      _desired: "orn",
      _distance: "10",
      _oneway: "true"
    } },
    { ms: {
      _desired: "ors",
      _distance: "10",
      _oneway: "true"
    } },
    { ms: {
      _desired: "pel",
      _distance: "10",
      _oneway: "true"
    } },
    { ms: {
      _desired: "pse",
      _distance: "10",
      _oneway: "true"
    } },
    { ms: {
      _desired: "tmw",
      _distance: "10",
      _oneway: "true"
    } },
    { ms: {
      _desired: "urk",
      _distance: "10",
      _oneway: "true"
    } },
    { ms: {
      _desired: "vkk",
      _distance: "10",
      _oneway: "true"
    } },
    { ms: {
      _desired: "vkt",
      _distance: "10",
      _oneway: "true"
    } },
    { ms: {
      _desired: "xmm",
      _distance: "10",
      _oneway: "true"
    } },
    { ms: {
      _desired: "zlm",
      _distance: "10",
      _oneway: "true"
    } },
    { ms: {
      _desired: "zmi",
      _distance: "10",
      _oneway: "true"
    } },
    { ne: {
      _desired: "dty",
      _distance: "10",
      _oneway: "true"
    } },
    { om: {
      _desired: "gax",
      _distance: "10",
      _oneway: "true"
    } },
    { om: {
      _desired: "hae",
      _distance: "10",
      _oneway: "true"
    } },
    { om: {
      _desired: "orc",
      _distance: "10",
      _oneway: "true"
    } },
    { or: {
      _desired: "spv",
      _distance: "10",
      _oneway: "true"
    } },
    { ps: {
      _desired: "pbt",
      _distance: "10",
      _oneway: "true"
    } },
    { ps: {
      _desired: "pst",
      _distance: "10",
      _oneway: "true"
    } },
    { qu: {
      _desired: "qub",
      _distance: "10",
      _oneway: "true"
    } },
    { qu: {
      _desired: "qud",
      _distance: "10",
      _oneway: "true"
    } },
    { qu: {
      _desired: "quf",
      _distance: "10",
      _oneway: "true"
    } },
    { qu: {
      _desired: "qug",
      _distance: "10",
      _oneway: "true"
    } },
    { qu: {
      _desired: "quh",
      _distance: "10",
      _oneway: "true"
    } },
    { qu: {
      _desired: "quk",
      _distance: "10",
      _oneway: "true"
    } },
    { qu: {
      _desired: "qul",
      _distance: "10",
      _oneway: "true"
    } },
    { qu: {
      _desired: "qup",
      _distance: "10",
      _oneway: "true"
    } },
    { qu: {
      _desired: "qur",
      _distance: "10",
      _oneway: "true"
    } },
    { qu: {
      _desired: "qus",
      _distance: "10",
      _oneway: "true"
    } },
    { qu: {
      _desired: "quw",
      _distance: "10",
      _oneway: "true"
    } },
    { qu: {
      _desired: "qux",
      _distance: "10",
      _oneway: "true"
    } },
    { qu: {
      _desired: "quy",
      _distance: "10",
      _oneway: "true"
    } },
    { qu: {
      _desired: "qva",
      _distance: "10",
      _oneway: "true"
    } },
    { qu: {
      _desired: "qvc",
      _distance: "10",
      _oneway: "true"
    } },
    { qu: {
      _desired: "qve",
      _distance: "10",
      _oneway: "true"
    } },
    { qu: {
      _desired: "qvh",
      _distance: "10",
      _oneway: "true"
    } },
    { qu: {
      _desired: "qvi",
      _distance: "10",
      _oneway: "true"
    } },
    { qu: {
      _desired: "qvj",
      _distance: "10",
      _oneway: "true"
    } },
    { qu: {
      _desired: "qvl",
      _distance: "10",
      _oneway: "true"
    } },
    { qu: {
      _desired: "qvm",
      _distance: "10",
      _oneway: "true"
    } },
    { qu: {
      _desired: "qvn",
      _distance: "10",
      _oneway: "true"
    } },
    { qu: {
      _desired: "qvo",
      _distance: "10",
      _oneway: "true"
    } },
    { qu: {
      _desired: "qvp",
      _distance: "10",
      _oneway: "true"
    } },
    { qu: {
      _desired: "qvs",
      _distance: "10",
      _oneway: "true"
    } },
    { qu: {
      _desired: "qvw",
      _distance: "10",
      _oneway: "true"
    } },
    { qu: {
      _desired: "qvz",
      _distance: "10",
      _oneway: "true"
    } },
    { qu: {
      _desired: "qwa",
      _distance: "10",
      _oneway: "true"
    } },
    { qu: {
      _desired: "qwc",
      _distance: "10",
      _oneway: "true"
    } },
    { qu: {
      _desired: "qwh",
      _distance: "10",
      _oneway: "true"
    } },
    { qu: {
      _desired: "qws",
      _distance: "10",
      _oneway: "true"
    } },
    { qu: {
      _desired: "qxa",
      _distance: "10",
      _oneway: "true"
    } },
    { qu: {
      _desired: "qxc",
      _distance: "10",
      _oneway: "true"
    } },
    { qu: {
      _desired: "qxh",
      _distance: "10",
      _oneway: "true"
    } },
    { qu: {
      _desired: "qxl",
      _distance: "10",
      _oneway: "true"
    } },
    { qu: {
      _desired: "qxn",
      _distance: "10",
      _oneway: "true"
    } },
    { qu: {
      _desired: "qxo",
      _distance: "10",
      _oneway: "true"
    } },
    { qu: {
      _desired: "qxp",
      _distance: "10",
      _oneway: "true"
    } },
    { qu: {
      _desired: "qxr",
      _distance: "10",
      _oneway: "true"
    } },
    { qu: {
      _desired: "qxt",
      _distance: "10",
      _oneway: "true"
    } },
    { qu: {
      _desired: "qxu",
      _distance: "10",
      _oneway: "true"
    } },
    { qu: {
      _desired: "qxw",
      _distance: "10",
      _oneway: "true"
    } },
    { sc: {
      _desired: "sdc",
      _distance: "10",
      _oneway: "true"
    } },
    { sc: {
      _desired: "sdn",
      _distance: "10",
      _oneway: "true"
    } },
    { sc: {
      _desired: "sro",
      _distance: "10",
      _oneway: "true"
    } },
    { sq: {
      _desired: "aae",
      _distance: "10",
      _oneway: "true"
    } },
    { sq: {
      _desired: "aat",
      _distance: "10",
      _oneway: "true"
    } },
    { sq: {
      _desired: "aln",
      _distance: "10",
      _oneway: "true"
    } },
    { syr: {
      _desired: "aii",
      _distance: "10",
      _oneway: "true"
    } },
    { uz: {
      _desired: "uzs",
      _distance: "10",
      _oneway: "true"
    } },
    { yi: {
      _desired: "yih",
      _distance: "10",
      _oneway: "true"
    } },
    { zh: {
      _desired: "cdo",
      _distance: "10",
      _oneway: "true"
    } },
    { zh: {
      _desired: "cjy",
      _distance: "10",
      _oneway: "true"
    } },
    { zh: {
      _desired: "cpx",
      _distance: "10",
      _oneway: "true"
    } },
    { zh: {
      _desired: "czh",
      _distance: "10",
      _oneway: "true"
    } },
    { zh: {
      _desired: "czo",
      _distance: "10",
      _oneway: "true"
    } },
    { zh: {
      _desired: "gan",
      _distance: "10",
      _oneway: "true"
    } },
    { zh: {
      _desired: "hak",
      _distance: "10",
      _oneway: "true"
    } },
    { zh: {
      _desired: "hsn",
      _distance: "10",
      _oneway: "true"
    } },
    { zh: {
      _desired: "lzh",
      _distance: "10",
      _oneway: "true"
    } },
    { zh: {
      _desired: "mnp",
      _distance: "10",
      _oneway: "true"
    } },
    { zh: {
      _desired: "nan",
      _distance: "10",
      _oneway: "true"
    } },
    { zh: {
      _desired: "wuu",
      _distance: "10",
      _oneway: "true"
    } },
    { zh: {
      _desired: "yue",
      _distance: "10",
      _oneway: "true"
    } },
    { "*": {
      _desired: "*",
      _distance: "80"
    } },
    { "en-Latn": {
      _desired: "am-Ethi",
      _distance: "10",
      _oneway: "true"
    } },
    { "ru-Cyrl": {
      _desired: "az-Latn",
      _distance: "10",
      _oneway: "true"
    } },
    { "en-Latn": {
      _desired: "bn-Beng",
      _distance: "10",
      _oneway: "true"
    } },
    { "zh-Hans": {
      _desired: "bo-Tibt",
      _distance: "10",
      _oneway: "true"
    } },
    { "ru-Cyrl": {
      _desired: "hy-Armn",
      _distance: "10",
      _oneway: "true"
    } },
    { "en-Latn": {
      _desired: "ka-Geor",
      _distance: "10",
      _oneway: "true"
    } },
    { "en-Latn": {
      _desired: "km-Khmr",
      _distance: "10",
      _oneway: "true"
    } },
    { "en-Latn": {
      _desired: "kn-Knda",
      _distance: "10",
      _oneway: "true"
    } },
    { "en-Latn": {
      _desired: "lo-Laoo",
      _distance: "10",
      _oneway: "true"
    } },
    { "en-Latn": {
      _desired: "ml-Mlym",
      _distance: "10",
      _oneway: "true"
    } },
    { "en-Latn": {
      _desired: "my-Mymr",
      _distance: "10",
      _oneway: "true"
    } },
    { "en-Latn": {
      _desired: "ne-Deva",
      _distance: "10",
      _oneway: "true"
    } },
    { "en-Latn": {
      _desired: "or-Orya",
      _distance: "10",
      _oneway: "true"
    } },
    { "en-Latn": {
      _desired: "pa-Guru",
      _distance: "10",
      _oneway: "true"
    } },
    { "en-Latn": {
      _desired: "ps-Arab",
      _distance: "10",
      _oneway: "true"
    } },
    { "en-Latn": {
      _desired: "sd-Arab",
      _distance: "10",
      _oneway: "true"
    } },
    { "en-Latn": {
      _desired: "si-Sinh",
      _distance: "10",
      _oneway: "true"
    } },
    { "en-Latn": {
      _desired: "ta-Taml",
      _distance: "10",
      _oneway: "true"
    } },
    { "en-Latn": {
      _desired: "te-Telu",
      _distance: "10",
      _oneway: "true"
    } },
    { "en-Latn": {
      _desired: "ti-Ethi",
      _distance: "10",
      _oneway: "true"
    } },
    { "ru-Cyrl": {
      _desired: "tk-Latn",
      _distance: "10",
      _oneway: "true"
    } },
    { "en-Latn": {
      _desired: "ur-Arab",
      _distance: "10",
      _oneway: "true"
    } },
    { "ru-Cyrl": {
      _desired: "uz-Latn",
      _distance: "10",
      _oneway: "true"
    } },
    { "en-Latn": {
      _desired: "yi-Hebr",
      _distance: "10",
      _oneway: "true"
    } },
    { "sr-Cyrl": {
      _desired: "sr-Latn",
      _distance: "5"
    } },
    { "zh-Hans": {
      _desired: "za-Latn",
      _distance: "10",
      _oneway: "true"
    } },
    { "zh-Hans": {
      _desired: "zh-Hani",
      _distance: "20",
      _oneway: "true"
    } },
    { "zh-Hant": {
      _desired: "zh-Hani",
      _distance: "20",
      _oneway: "true"
    } },
    { "ar-Arab": {
      _desired: "ar-Latn",
      _distance: "20",
      _oneway: "true"
    } },
    { "bn-Beng": {
      _desired: "bn-Latn",
      _distance: "20",
      _oneway: "true"
    } },
    { "gu-Gujr": {
      _desired: "gu-Latn",
      _distance: "20",
      _oneway: "true"
    } },
    { "hi-Deva": {
      _desired: "hi-Latn",
      _distance: "20",
      _oneway: "true"
    } },
    { "kn-Knda": {
      _desired: "kn-Latn",
      _distance: "20",
      _oneway: "true"
    } },
    { "ml-Mlym": {
      _desired: "ml-Latn",
      _distance: "20",
      _oneway: "true"
    } },
    { "mr-Deva": {
      _desired: "mr-Latn",
      _distance: "20",
      _oneway: "true"
    } },
    { "ta-Taml": {
      _desired: "ta-Latn",
      _distance: "20",
      _oneway: "true"
    } },
    { "te-Telu": {
      _desired: "te-Latn",
      _distance: "20",
      _oneway: "true"
    } },
    { "zh-Hans": {
      _desired: "zh-Latn",
      _distance: "20",
      _oneway: "true"
    } },
    { "ja-Jpan": {
      _desired: "ja-Latn",
      _distance: "5",
      _oneway: "true"
    } },
    { "ja-Jpan": {
      _desired: "ja-Hani",
      _distance: "5",
      _oneway: "true"
    } },
    { "ja-Jpan": {
      _desired: "ja-Hira",
      _distance: "5",
      _oneway: "true"
    } },
    { "ja-Jpan": {
      _desired: "ja-Kana",
      _distance: "5",
      _oneway: "true"
    } },
    { "ja-Jpan": {
      _desired: "ja-Hrkt",
      _distance: "5",
      _oneway: "true"
    } },
    { "ja-Hrkt": {
      _desired: "ja-Hira",
      _distance: "5",
      _oneway: "true"
    } },
    { "ja-Hrkt": {
      _desired: "ja-Kana",
      _distance: "5",
      _oneway: "true"
    } },
    { "ko-Kore": {
      _desired: "ko-Hani",
      _distance: "5",
      _oneway: "true"
    } },
    { "ko-Kore": {
      _desired: "ko-Hang",
      _distance: "5",
      _oneway: "true"
    } },
    { "ko-Kore": {
      _desired: "ko-Jamo",
      _distance: "5",
      _oneway: "true"
    } },
    { "ko-Hang": {
      _desired: "ko-Jamo",
      _distance: "5",
      _oneway: "true"
    } },
    { "*-*": {
      _desired: "*-*",
      _distance: "50"
    } },
    { "ar-*-$maghreb": {
      _desired: "ar-*-$maghreb",
      _distance: "4"
    } },
    { "ar-*-$!maghreb": {
      _desired: "ar-*-$!maghreb",
      _distance: "4"
    } },
    { "ar-*-*": {
      _desired: "ar-*-*",
      _distance: "5"
    } },
    { "en-*-$enUS": {
      _desired: "en-*-$enUS",
      _distance: "4"
    } },
    { "en-*-GB": {
      _desired: "en-*-$!enUS",
      _distance: "3"
    } },
    { "en-*-$!enUS": {
      _desired: "en-*-$!enUS",
      _distance: "4"
    } },
    { "en-*-*": {
      _desired: "en-*-*",
      _distance: "5"
    } },
    { "es-*-$americas": {
      _desired: "es-*-$americas",
      _distance: "4"
    } },
    { "es-*-$!americas": {
      _desired: "es-*-$!americas",
      _distance: "4"
    } },
    { "es-*-*": {
      _desired: "es-*-*",
      _distance: "5"
    } },
    { "pt-*-$americas": {
      _desired: "pt-*-$americas",
      _distance: "4"
    } },
    { "pt-*-$!americas": {
      _desired: "pt-*-$!americas",
      _distance: "4"
    } },
    { "pt-*-*": {
      _desired: "pt-*-*",
      _distance: "5"
    } },
    { "zh-Hant-$cnsar": {
      _desired: "zh-Hant-$cnsar",
      _distance: "4"
    } },
    { "zh-Hant-$!cnsar": {
      _desired: "zh-Hant-$!cnsar",
      _distance: "4"
    } },
    { "zh-Hant-*": {
      _desired: "zh-Hant-*",
      _distance: "5"
    } },
    { "*-*-*": {
      _desired: "*-*-*",
      _distance: "4"
    } }
  ] } } };

  // node_modules/.aspect_rules_js/@formatjs+intl-localematcher@0.0.0/node_modules/@formatjs/intl-localematcher/abstract/regions.generated.js
  var regions = {
    "001": [
      "001",
      "001-status-grouping",
      "002",
      "005",
      "009",
      "011",
      "013",
      "014",
      "015",
      "017",
      "018",
      "019",
      "021",
      "029",
      "030",
      "034",
      "035",
      "039",
      "053",
      "054",
      "057",
      "061",
      "142",
      "143",
      "145",
      "150",
      "151",
      "154",
      "155",
      "AC",
      "AD",
      "AE",
      "AF",
      "AG",
      "AI",
      "AL",
      "AM",
      "AO",
      "AQ",
      "AR",
      "AS",
      "AT",
      "AU",
      "AW",
      "AX",
      "AZ",
      "BA",
      "BB",
      "BD",
      "BE",
      "BF",
      "BG",
      "BH",
      "BI",
      "BJ",
      "BL",
      "BM",
      "BN",
      "BO",
      "BQ",
      "BR",
      "BS",
      "BT",
      "BV",
      "BW",
      "BY",
      "BZ",
      "CA",
      "CC",
      "CD",
      "CF",
      "CG",
      "CH",
      "CI",
      "CK",
      "CL",
      "CM",
      "CN",
      "CO",
      "CP",
      "CQ",
      "CR",
      "CU",
      "CV",
      "CW",
      "CX",
      "CY",
      "CZ",
      "DE",
      "DG",
      "DJ",
      "DK",
      "DM",
      "DO",
      "DZ",
      "EA",
      "EC",
      "EE",
      "EG",
      "EH",
      "ER",
      "ES",
      "ET",
      "EU",
      "EZ",
      "FI",
      "FJ",
      "FK",
      "FM",
      "FO",
      "FR",
      "GA",
      "GB",
      "GD",
      "GE",
      "GF",
      "GG",
      "GH",
      "GI",
      "GL",
      "GM",
      "GN",
      "GP",
      "GQ",
      "GR",
      "GS",
      "GT",
      "GU",
      "GW",
      "GY",
      "HK",
      "HM",
      "HN",
      "HR",
      "HT",
      "HU",
      "IC",
      "ID",
      "IE",
      "IL",
      "IM",
      "IN",
      "IO",
      "IQ",
      "IR",
      "IS",
      "IT",
      "JE",
      "JM",
      "JO",
      "JP",
      "KE",
      "KG",
      "KH",
      "KI",
      "KM",
      "KN",
      "KP",
      "KR",
      "KW",
      "KY",
      "KZ",
      "LA",
      "LB",
      "LC",
      "LI",
      "LK",
      "LR",
      "LS",
      "LT",
      "LU",
      "LV",
      "LY",
      "MA",
      "MC",
      "MD",
      "ME",
      "MF",
      "MG",
      "MH",
      "MK",
      "ML",
      "MM",
      "MN",
      "MO",
      "MP",
      "MQ",
      "MR",
      "MS",
      "MT",
      "MU",
      "MV",
      "MW",
      "MX",
      "MY",
      "MZ",
      "NA",
      "NC",
      "NE",
      "NF",
      "NG",
      "NI",
      "NL",
      "NO",
      "NP",
      "NR",
      "NU",
      "NZ",
      "OM",
      "PA",
      "PE",
      "PF",
      "PG",
      "PH",
      "PK",
      "PL",
      "PM",
      "PN",
      "PR",
      "PS",
      "PT",
      "PW",
      "PY",
      "QA",
      "QO",
      "RE",
      "RO",
      "RS",
      "RU",
      "RW",
      "SA",
      "SB",
      "SC",
      "SD",
      "SE",
      "SG",
      "SH",
      "SI",
      "SJ",
      "SK",
      "SL",
      "SM",
      "SN",
      "SO",
      "SR",
      "SS",
      "ST",
      "SV",
      "SX",
      "SY",
      "SZ",
      "TA",
      "TC",
      "TD",
      "TF",
      "TG",
      "TH",
      "TJ",
      "TK",
      "TL",
      "TM",
      "TN",
      "TO",
      "TR",
      "TT",
      "TV",
      "TW",
      "TZ",
      "UA",
      "UG",
      "UM",
      "UN",
      "US",
      "UY",
      "UZ",
      "VA",
      "VC",
      "VE",
      "VG",
      "VI",
      "VN",
      "VU",
      "WF",
      "WS",
      "XK",
      "YE",
      "YT",
      "ZA",
      "ZM",
      "ZW"
    ],
    "002": [
      "002",
      "002-status-grouping",
      "011",
      "014",
      "015",
      "017",
      "018",
      "202",
      "AO",
      "BF",
      "BI",
      "BJ",
      "BW",
      "CD",
      "CF",
      "CG",
      "CI",
      "CM",
      "CV",
      "DJ",
      "DZ",
      "EA",
      "EG",
      "EH",
      "ER",
      "ET",
      "GA",
      "GH",
      "GM",
      "GN",
      "GQ",
      "GW",
      "IC",
      "IO",
      "KE",
      "KM",
      "LR",
      "LS",
      "LY",
      "MA",
      "MG",
      "ML",
      "MR",
      "MU",
      "MW",
      "MZ",
      "NA",
      "NE",
      "NG",
      "RE",
      "RW",
      "SC",
      "SD",
      "SH",
      "SL",
      "SN",
      "SO",
      "SS",
      "ST",
      "SZ",
      "TD",
      "TF",
      "TG",
      "TN",
      "TZ",
      "UG",
      "YT",
      "ZA",
      "ZM",
      "ZW"
    ],
    "003": [
      "003",
      "013",
      "021",
      "029",
      "AG",
      "AI",
      "AW",
      "BB",
      "BL",
      "BM",
      "BQ",
      "BS",
      "BZ",
      "CA",
      "CR",
      "CU",
      "CW",
      "DM",
      "DO",
      "GD",
      "GL",
      "GP",
      "GT",
      "HN",
      "HT",
      "JM",
      "KN",
      "KY",
      "LC",
      "MF",
      "MQ",
      "MS",
      "MX",
      "NI",
      "PA",
      "PM",
      "PR",
      "SV",
      "SX",
      "TC",
      "TT",
      "US",
      "VC",
      "VG",
      "VI"
    ],
    "005": [
      "005",
      "AR",
      "BO",
      "BR",
      "BV",
      "CL",
      "CO",
      "EC",
      "FK",
      "GF",
      "GS",
      "GY",
      "PE",
      "PY",
      "SR",
      "UY",
      "VE"
    ],
    "009": [
      "009",
      "053",
      "054",
      "057",
      "061",
      "AC",
      "AQ",
      "AS",
      "AU",
      "CC",
      "CK",
      "CP",
      "CX",
      "DG",
      "FJ",
      "FM",
      "GU",
      "HM",
      "KI",
      "MH",
      "MP",
      "NC",
      "NF",
      "NR",
      "NU",
      "NZ",
      "PF",
      "PG",
      "PN",
      "PW",
      "QO",
      "SB",
      "TA",
      "TK",
      "TO",
      "TV",
      "UM",
      "VU",
      "WF",
      "WS"
    ],
    "011": [
      "011",
      "BF",
      "BJ",
      "CI",
      "CV",
      "GH",
      "GM",
      "GN",
      "GW",
      "LR",
      "ML",
      "MR",
      "NE",
      "NG",
      "SH",
      "SL",
      "SN",
      "TG"
    ],
    "013": [
      "013",
      "BZ",
      "CR",
      "GT",
      "HN",
      "MX",
      "NI",
      "PA",
      "SV"
    ],
    "014": [
      "014",
      "BI",
      "DJ",
      "ER",
      "ET",
      "IO",
      "KE",
      "KM",
      "MG",
      "MU",
      "MW",
      "MZ",
      "RE",
      "RW",
      "SC",
      "SO",
      "SS",
      "TF",
      "TZ",
      "UG",
      "YT",
      "ZM",
      "ZW"
    ],
    "015": [
      "015",
      "DZ",
      "EA",
      "EG",
      "EH",
      "IC",
      "LY",
      "MA",
      "SD",
      "TN"
    ],
    "017": [
      "017",
      "AO",
      "CD",
      "CF",
      "CG",
      "CM",
      "GA",
      "GQ",
      "ST",
      "TD"
    ],
    "018": [
      "018",
      "BW",
      "LS",
      "NA",
      "SZ",
      "ZA"
    ],
    "019": [
      "003",
      "005",
      "013",
      "019",
      "019-status-grouping",
      "021",
      "029",
      "419",
      "AG",
      "AI",
      "AR",
      "AW",
      "BB",
      "BL",
      "BM",
      "BO",
      "BQ",
      "BR",
      "BS",
      "BV",
      "BZ",
      "CA",
      "CL",
      "CO",
      "CR",
      "CU",
      "CW",
      "DM",
      "DO",
      "EC",
      "FK",
      "GD",
      "GF",
      "GL",
      "GP",
      "GS",
      "GT",
      "GY",
      "HN",
      "HT",
      "JM",
      "KN",
      "KY",
      "LC",
      "MF",
      "MQ",
      "MS",
      "MX",
      "NI",
      "PA",
      "PE",
      "PM",
      "PR",
      "PY",
      "SR",
      "SV",
      "SX",
      "TC",
      "TT",
      "US",
      "UY",
      "VC",
      "VE",
      "VG",
      "VI"
    ],
    "021": [
      "021",
      "BM",
      "CA",
      "GL",
      "PM",
      "US"
    ],
    "029": [
      "029",
      "AG",
      "AI",
      "AW",
      "BB",
      "BL",
      "BQ",
      "BS",
      "CU",
      "CW",
      "DM",
      "DO",
      "GD",
      "GP",
      "HT",
      "JM",
      "KN",
      "KY",
      "LC",
      "MF",
      "MQ",
      "MS",
      "PR",
      "SX",
      "TC",
      "TT",
      "VC",
      "VG",
      "VI"
    ],
    "030": [
      "030",
      "CN",
      "HK",
      "JP",
      "KP",
      "KR",
      "MN",
      "MO",
      "TW"
    ],
    "034": [
      "034",
      "AF",
      "BD",
      "BT",
      "IN",
      "IR",
      "LK",
      "MV",
      "NP",
      "PK"
    ],
    "035": [
      "035",
      "BN",
      "ID",
      "KH",
      "LA",
      "MM",
      "MY",
      "PH",
      "SG",
      "TH",
      "TL",
      "VN"
    ],
    "039": [
      "039",
      "AD",
      "AL",
      "BA",
      "ES",
      "GI",
      "GR",
      "HR",
      "IT",
      "ME",
      "MK",
      "MT",
      "PT",
      "RS",
      "SI",
      "SM",
      "VA",
      "XK"
    ],
    "053": [
      "053",
      "AU",
      "CC",
      "CX",
      "HM",
      "NF",
      "NZ"
    ],
    "054": [
      "054",
      "FJ",
      "NC",
      "PG",
      "SB",
      "VU"
    ],
    "057": [
      "057",
      "FM",
      "GU",
      "KI",
      "MH",
      "MP",
      "NR",
      "PW",
      "UM"
    ],
    "061": [
      "061",
      "AS",
      "CK",
      "NU",
      "PF",
      "PN",
      "TK",
      "TO",
      "TV",
      "WF",
      "WS"
    ],
    "142": [
      "030",
      "034",
      "035",
      "142",
      "143",
      "145",
      "AE",
      "AF",
      "AM",
      "AZ",
      "BD",
      "BH",
      "BN",
      "BT",
      "CN",
      "CY",
      "GE",
      "HK",
      "ID",
      "IL",
      "IN",
      "IQ",
      "IR",
      "JO",
      "JP",
      "KG",
      "KH",
      "KP",
      "KR",
      "KW",
      "KZ",
      "LA",
      "LB",
      "LK",
      "MM",
      "MN",
      "MO",
      "MV",
      "MY",
      "NP",
      "OM",
      "PH",
      "PK",
      "PS",
      "QA",
      "SA",
      "SG",
      "SY",
      "TH",
      "TJ",
      "TL",
      "TM",
      "TR",
      "TW",
      "UZ",
      "VN",
      "YE"
    ],
    "143": [
      "143",
      "KG",
      "KZ",
      "TJ",
      "TM",
      "UZ"
    ],
    "145": [
      "145",
      "AE",
      "AM",
      "AZ",
      "BH",
      "CY",
      "GE",
      "IL",
      "IQ",
      "JO",
      "KW",
      "LB",
      "OM",
      "PS",
      "QA",
      "SA",
      "SY",
      "TR",
      "YE"
    ],
    "150": [
      "039",
      "150",
      "151",
      "154",
      "155",
      "AD",
      "AL",
      "AT",
      "AX",
      "BA",
      "BE",
      "BG",
      "BY",
      "CH",
      "CQ",
      "CZ",
      "DE",
      "DK",
      "EE",
      "ES",
      "FI",
      "FO",
      "FR",
      "GB",
      "GG",
      "GI",
      "GR",
      "HR",
      "HU",
      "IE",
      "IM",
      "IS",
      "IT",
      "JE",
      "LI",
      "LT",
      "LU",
      "LV",
      "MC",
      "MD",
      "ME",
      "MK",
      "MT",
      "NL",
      "NO",
      "PL",
      "PT",
      "RO",
      "RS",
      "RU",
      "SE",
      "SI",
      "SJ",
      "SK",
      "SM",
      "UA",
      "VA",
      "XK"
    ],
    "151": [
      "151",
      "BG",
      "BY",
      "CZ",
      "HU",
      "MD",
      "PL",
      "RO",
      "RU",
      "SK",
      "UA"
    ],
    "154": [
      "154",
      "AX",
      "CQ",
      "DK",
      "EE",
      "FI",
      "FO",
      "GB",
      "GG",
      "IE",
      "IM",
      "IS",
      "JE",
      "LT",
      "LV",
      "NO",
      "SE",
      "SJ"
    ],
    "155": [
      "155",
      "AT",
      "BE",
      "CH",
      "DE",
      "FR",
      "LI",
      "LU",
      "MC",
      "NL"
    ],
    "202": [
      "011",
      "014",
      "017",
      "018",
      "202",
      "AO",
      "BF",
      "BI",
      "BJ",
      "BW",
      "CD",
      "CF",
      "CG",
      "CI",
      "CM",
      "CV",
      "DJ",
      "ER",
      "ET",
      "GA",
      "GH",
      "GM",
      "GN",
      "GQ",
      "GW",
      "IO",
      "KE",
      "KM",
      "LR",
      "LS",
      "MG",
      "ML",
      "MR",
      "MU",
      "MW",
      "MZ",
      "NA",
      "NE",
      "NG",
      "RE",
      "RW",
      "SC",
      "SH",
      "SL",
      "SN",
      "SO",
      "SS",
      "ST",
      "SZ",
      "TD",
      "TF",
      "TG",
      "TZ",
      "UG",
      "YT",
      "ZA",
      "ZM",
      "ZW"
    ],
    "419": [
      "005",
      "013",
      "029",
      "419",
      "AG",
      "AI",
      "AR",
      "AW",
      "BB",
      "BL",
      "BO",
      "BQ",
      "BR",
      "BS",
      "BV",
      "BZ",
      "CL",
      "CO",
      "CR",
      "CU",
      "CW",
      "DM",
      "DO",
      "EC",
      "FK",
      "GD",
      "GF",
      "GP",
      "GS",
      "GT",
      "GY",
      "HN",
      "HT",
      "JM",
      "KN",
      "KY",
      "LC",
      "MF",
      "MQ",
      "MS",
      "MX",
      "NI",
      "PA",
      "PE",
      "PR",
      "PY",
      "SR",
      "SV",
      "SX",
      "TC",
      "TT",
      "UY",
      "VC",
      "VE",
      "VG",
      "VI"
    ],
    EU: [
      "AT",
      "BE",
      "BG",
      "CY",
      "CZ",
      "DE",
      "DK",
      "EE",
      "ES",
      "EU",
      "FI",
      "FR",
      "GR",
      "HR",
      "HU",
      "IE",
      "IT",
      "LT",
      "LU",
      "LV",
      "MT",
      "NL",
      "PL",
      "PT",
      "RO",
      "SE",
      "SI",
      "SK"
    ],
    EZ: [
      "AT",
      "BE",
      "CY",
      "DE",
      "EE",
      "ES",
      "EZ",
      "FI",
      "FR",
      "GR",
      "IE",
      "IT",
      "LT",
      "LU",
      "LV",
      "MT",
      "NL",
      "PT",
      "SI",
      "SK"
    ],
    QO: [
      "AC",
      "AQ",
      "CP",
      "DG",
      "QO",
      "TA"
    ],
    UN: [
      "AD",
      "AE",
      "AF",
      "AG",
      "AL",
      "AM",
      "AO",
      "AR",
      "AT",
      "AU",
      "AZ",
      "BA",
      "BB",
      "BD",
      "BE",
      "BF",
      "BG",
      "BH",
      "BI",
      "BJ",
      "BN",
      "BO",
      "BR",
      "BS",
      "BT",
      "BW",
      "BY",
      "BZ",
      "CA",
      "CD",
      "CF",
      "CG",
      "CH",
      "CI",
      "CL",
      "CM",
      "CN",
      "CO",
      "CR",
      "CU",
      "CV",
      "CY",
      "CZ",
      "DE",
      "DJ",
      "DK",
      "DM",
      "DO",
      "DZ",
      "EC",
      "EE",
      "EG",
      "ER",
      "ES",
      "ET",
      "FI",
      "FJ",
      "FM",
      "FR",
      "GA",
      "GB",
      "GD",
      "GE",
      "GH",
      "GM",
      "GN",
      "GQ",
      "GR",
      "GT",
      "GW",
      "GY",
      "HN",
      "HR",
      "HT",
      "HU",
      "ID",
      "IE",
      "IL",
      "IN",
      "IQ",
      "IR",
      "IS",
      "IT",
      "JM",
      "JO",
      "JP",
      "KE",
      "KG",
      "KH",
      "KI",
      "KM",
      "KN",
      "KP",
      "KR",
      "KW",
      "KZ",
      "LA",
      "LB",
      "LC",
      "LI",
      "LK",
      "LR",
      "LS",
      "LT",
      "LU",
      "LV",
      "LY",
      "MA",
      "MC",
      "MD",
      "ME",
      "MG",
      "MH",
      "MK",
      "ML",
      "MM",
      "MN",
      "MR",
      "MT",
      "MU",
      "MV",
      "MW",
      "MX",
      "MY",
      "MZ",
      "NA",
      "NE",
      "NG",
      "NI",
      "NL",
      "NO",
      "NP",
      "NR",
      "NZ",
      "OM",
      "PA",
      "PE",
      "PG",
      "PH",
      "PK",
      "PL",
      "PT",
      "PW",
      "PY",
      "QA",
      "RO",
      "RS",
      "RU",
      "RW",
      "SA",
      "SB",
      "SC",
      "SD",
      "SE",
      "SG",
      "SI",
      "SK",
      "SL",
      "SM",
      "SN",
      "SO",
      "SR",
      "SS",
      "ST",
      "SV",
      "SY",
      "SZ",
      "TD",
      "TG",
      "TH",
      "TJ",
      "TL",
      "TM",
      "TN",
      "TO",
      "TR",
      "TT",
      "TV",
      "TZ",
      "UA",
      "UG",
      "UN",
      "US",
      "UY",
      "UZ",
      "VC",
      "VE",
      "VN",
      "VU",
      "WS",
      "YE",
      "ZA",
      "ZM",
      "ZW"
    ]
  };

  // node_modules/.aspect_rules_js/@formatjs+intl-localematcher@0.0.0/node_modules/@formatjs/intl-localematcher/abstract/utils.js
  var PROCESSED_DATA;
  function processData() {
    var _a2, _b;
    if (!PROCESSED_DATA) {
      const paradigmLocales = (_b = (_a2 = data.supplemental.languageMatching["written-new"][0]) == null ? void 0 : _a2.paradigmLocales) == null ? void 0 : _b._locales.split(" ");
      const matchVariables = data.supplemental.languageMatching["written-new"].slice(1, 5);
      const data2 = data.supplemental.languageMatching["written-new"].slice(5);
      const matches = data2.map((d) => {
        const key = Object.keys(d)[0];
        const value = d[key];
        return {
          supported: key,
          desired: value._desired,
          distance: +value._distance,
          oneway: value.oneway === "true" ? true : false
        };
      }, {});
      PROCESSED_DATA = {
        matches,
        matchVariables: matchVariables.reduce((all, d) => {
          const key = Object.keys(d)[0];
          const value = d[key];
          all[key.slice(1)] = value._value.split("+");
          return all;
        }, {}),
        paradigmLocales: [...paradigmLocales, ...paradigmLocales.map((l) => new Intl.Locale(l.replace(/_/g, "-")).maximize().toString())]
      };
    }
    return PROCESSED_DATA;
  }
  function isMatched(locale, languageMatchInfoLocale, matchVariables) {
    const [language, script, region] = languageMatchInfoLocale.split("-");
    let matches = true;
    if (region && region[0] === "$") {
      const shouldInclude = region[1] !== "!";
      const matchRegions = shouldInclude ? matchVariables[region.slice(1)] : matchVariables[region.slice(2)];
      const expandedMatchedRegions = matchRegions.map((r) => regions[r] || [r]).reduce((all, list) => [...all, ...list], []);
      matches && (matches = !(expandedMatchedRegions.indexOf(locale.region || "") > -1 != shouldInclude));
    } else {
      matches && (matches = locale.region ? region === "*" || region === locale.region : true);
    }
    matches && (matches = locale.script ? script === "*" || script === locale.script : true);
    matches && (matches = locale.language ? language === "*" || language === locale.language : true);
    return matches;
  }
  function serializeLSR(lsr) {
    return [
      lsr.language,
      lsr.script,
      lsr.region
    ].filter(Boolean).join("-");
  }
  function findMatchingDistanceForLSR(desired, supported, data2) {
    for (const d of data2.matches) {
      let matches = isMatched(desired, d.desired, data2.matchVariables) && isMatched(supported, d.supported, data2.matchVariables);
      if (!d.oneway && !matches) {
        matches = isMatched(desired, d.supported, data2.matchVariables) && isMatched(supported, d.desired, data2.matchVariables);
      }
      if (matches) {
        const distance = d.distance * 10;
        if (data2.paradigmLocales.indexOf(serializeLSR(desired)) > -1 != data2.paradigmLocales.indexOf(serializeLSR(supported)) > -1) {
          return distance - 1;
        }
        return distance;
      }
    }
    throw new Error("No matching distance found");
  }
  function findMatchingDistanceImpl(desired, supported) {
    const desiredLocale = new Intl.Locale(desired).maximize();
    const supportedLocale = new Intl.Locale(supported).maximize();
    const desiredLSR = {
      language: desiredLocale.language,
      script: desiredLocale.script || "",
      region: desiredLocale.region || ""
    };
    const supportedLSR = {
      language: supportedLocale.language,
      script: supportedLocale.script || "",
      region: supportedLocale.region || ""
    };
    let matchingDistance = 0;
    const data2 = processData();
    if (desiredLSR.language !== supportedLSR.language) {
      matchingDistance += findMatchingDistanceForLSR({
        language: desiredLocale.language,
        script: "",
        region: ""
      }, {
        language: supportedLocale.language,
        script: "",
        region: ""
      }, data2);
    }
    if (desiredLSR.script !== supportedLSR.script) {
      matchingDistance += findMatchingDistanceForLSR({
        language: desiredLocale.language,
        script: desiredLSR.script,
        region: ""
      }, {
        language: supportedLocale.language,
        script: supportedLSR.script,
        region: ""
      }, data2);
    }
    if (desiredLSR.region !== supportedLSR.region) {
      matchingDistance += findMatchingDistanceForLSR(desiredLSR, supportedLSR, data2);
    }
    return matchingDistance;
  }
  var findMatchingDistance = memoize(findMatchingDistanceImpl, { serializer: (args) => `${args[0]}|${args[1]}` });

  // node_modules/.aspect_rules_js/@formatjs+ecma402-abstract@0.0.0/node_modules/@formatjs/ecma402-abstract/types/date-time.js
  var RangePatternType = function(RangePatternType2) {
    RangePatternType2["startRange"] = "startRange";
    RangePatternType2["shared"] = "shared";
    RangePatternType2["endRange"] = "endRange";
    return RangePatternType2;
  }({});

  // node_modules/.aspect_rules_js/intl-messageformat@0.0.0/node_modules/intl-messageformat/src/error.js
  var ErrorCode = function(ErrorCode2) {
    ErrorCode2["MISSING_VALUE"] = "MISSING_VALUE";
    ErrorCode2["INVALID_VALUE"] = "INVALID_VALUE";
    ErrorCode2["MISSING_INTL_API"] = "MISSING_INTL_API";
    return ErrorCode2;
  }({});
  var FormatError = class extends Error {
    constructor(msg, code, originalMessage) {
      super(msg);
      __publicField(this, "code");
      /**
      * Original message we're trying to format
      * `undefined` if we're only dealing w/ AST
      *
      * @type {(string | undefined)}
      * @memberof FormatError
      */
      __publicField(this, "originalMessage");
      this.code = code;
      this.originalMessage = originalMessage;
    }
    toString() {
      return `[formatjs Error: ${this.code}] ${this.message}`;
    }
  };
  var InvalidValueError = class extends FormatError {
    constructor(variableId, value, options, originalMessage) {
      super(`Invalid values for "${variableId}": "${value}". Options are "${Object.keys(options).join('", "')}"`, ErrorCode.INVALID_VALUE, originalMessage);
    }
  };
  var InvalidValueTypeError = class extends FormatError {
    constructor(value, type, originalMessage) {
      super(`Value for "${value}" must be of type ${type}`, ErrorCode.INVALID_VALUE, originalMessage);
    }
  };
  var MissingValueError = class extends FormatError {
    constructor(variableId, originalMessage) {
      super(`The intl string context variable "${variableId}" was not provided to the string "${originalMessage}"`, ErrorCode.MISSING_VALUE, originalMessage);
    }
  };

  // node_modules/.aspect_rules_js/intl-messageformat@0.0.0/node_modules/intl-messageformat/src/formatters.js
  var PART_TYPE = function(PART_TYPE2) {
    PART_TYPE2[PART_TYPE2["literal"] = 0] = "literal";
    PART_TYPE2[PART_TYPE2["object"] = 1] = "object";
    return PART_TYPE2;
  }({});
  function mergeLiteral(parts) {
    if (parts.length < 2) {
      return parts;
    }
    return parts.reduce((all, part) => {
      const lastPart = all[all.length - 1];
      if (!lastPart || lastPart.type !== PART_TYPE.literal || part.type !== PART_TYPE.literal) {
        all.push(part);
      } else {
        lastPart.value += part.value;
      }
      return all;
    }, []);
  }
  function isFormatXMLElementFn(el) {
    return typeof el === "function";
  }
  function formatToParts2(els, locales, formatters, formats, values, currentPluralValue, originalMessage) {
    if (els.length === 1 && isLiteralElement(els[0])) {
      return [{
        type: PART_TYPE.literal,
        value: els[0].value
      }];
    }
    const result = [];
    for (const el of els) {
      if (isLiteralElement(el)) {
        result.push({
          type: PART_TYPE.literal,
          value: el.value
        });
        continue;
      }
      if (isPoundElement(el)) {
        if (typeof currentPluralValue === "number") {
          result.push({
            type: PART_TYPE.literal,
            value: formatters.getNumberFormat(locales).format(currentPluralValue)
          });
        }
        continue;
      }
      const { value: varName } = el;
      if (!(values && varName in values)) {
        throw new MissingValueError(varName, originalMessage);
      }
      let value = values[varName];
      if (isArgumentElement(el)) {
        if (!value || typeof value === "string" || typeof value === "number" || typeof value === "bigint") {
          value = typeof value === "string" || typeof value === "number" || typeof value === "bigint" ? String(value) : "";
        }
        result.push({
          type: typeof value === "string" ? PART_TYPE.literal : PART_TYPE.object,
          value
        });
        continue;
      }
      if (isDateElement(el)) {
        const style = typeof el.style === "string" ? formats.date[el.style] : isDateTimeSkeleton(el.style) ? el.style.parsedOptions : void 0;
        result.push({
          type: PART_TYPE.literal,
          value: formatters.getDateTimeFormat(locales, style).format(value)
        });
        continue;
      }
      if (isTimeElement(el)) {
        const style = typeof el.style === "string" ? formats.time[el.style] : isDateTimeSkeleton(el.style) ? el.style.parsedOptions : formats.time.medium;
        result.push({
          type: PART_TYPE.literal,
          value: formatters.getDateTimeFormat(locales, style).format(value)
        });
        continue;
      }
      if (isNumberElement(el)) {
        const style = typeof el.style === "string" ? formats.number[el.style] : isNumberSkeleton(el.style) ? el.style.parsedOptions : void 0;
        if (style && style.scale) {
          const scale = style.scale || 1;
          if (typeof value === "bigint") {
            if (!Number.isInteger(scale)) {
              throw new TypeError(`Cannot apply fractional scale ${scale} to bigint value. Scale must be an integer when formatting bigint.`);
            }
            value = value * BigInt(scale);
          } else {
            value = value * scale;
          }
        }
        result.push({
          type: PART_TYPE.literal,
          value: formatters.getNumberFormat(locales, style).format(value)
        });
        continue;
      }
      if (isTagElement(el)) {
        const { children, value: value2 } = el;
        const formatFn = values[value2];
        if (!isFormatXMLElementFn(formatFn)) {
          throw new InvalidValueTypeError(value2, "function", originalMessage);
        }
        const parts = formatToParts2(children, locales, formatters, formats, values, currentPluralValue);
        let chunks = formatFn(parts.map((p) => p.value));
        if (!Array.isArray(chunks)) {
          chunks = [chunks];
        }
        result.push(...chunks.map((c) => {
          return {
            type: typeof c === "string" ? PART_TYPE.literal : PART_TYPE.object,
            value: c
          };
        }));
      }
      if (isSelectElement(el)) {
        const key = value;
        const opt = (Object.prototype.hasOwnProperty.call(el.options, key) ? el.options[key] : void 0) || el.options.other;
        if (!opt) {
          throw new InvalidValueError(el.value, value, Object.keys(el.options), originalMessage);
        }
        result.push(...formatToParts2(opt.value, locales, formatters, formats, values));
        continue;
      }
      if (isPluralElement(el)) {
        const exactKey = `=${value}`;
        let opt = Object.prototype.hasOwnProperty.call(el.options, exactKey) ? el.options[exactKey] : void 0;
        if (!opt) {
          if (!Intl.PluralRules) {
            throw new FormatError(`Intl.PluralRules is not available in this environment.
Try polyfilling it using "@formatjs/intl-pluralrules"
`, ErrorCode.MISSING_INTL_API, originalMessage);
          }
          const numericValue2 = typeof value === "bigint" ? Number(value) : value;
          const rule = formatters.getPluralRules(locales, { type: el.pluralType }).select(numericValue2 - (el.offset || 0));
          opt = (Object.prototype.hasOwnProperty.call(el.options, rule) ? el.options[rule] : void 0) || el.options.other;
        }
        if (!opt) {
          throw new InvalidValueError(el.value, value, Object.keys(el.options), originalMessage);
        }
        const numericValue = typeof value === "bigint" ? Number(value) : value;
        result.push(...formatToParts2(opt.value, locales, formatters, formats, values, numericValue - (el.offset || 0)));
        continue;
      }
    }
    return mergeLiteral(result);
  }

  // node_modules/.aspect_rules_js/intl-messageformat@0.0.0/node_modules/intl-messageformat/src/core.js
  function mergeConfig(c1, c2) {
    if (!c2) {
      return c1;
    }
    return __spreadValues(__spreadValues(__spreadValues({}, c1), c2), Object.keys(c1).reduce((all, k) => {
      all[k] = __spreadValues(__spreadValues({}, c1[k]), c2[k]);
      return all;
    }, {}));
  }
  function mergeConfigs(defaultConfig, configs) {
    if (!configs) {
      return defaultConfig;
    }
    return Object.keys(defaultConfig).reduce((all, k) => {
      all[k] = mergeConfig(defaultConfig[k], configs[k]);
      return all;
    }, __spreadValues({}, defaultConfig));
  }
  function createFastMemoizeCache(store) {
    return { create() {
      return {
        get(key) {
          return store[key];
        },
        set(key, value) {
          store[key] = value;
        }
      };
    } };
  }
  function createDefaultFormatters(cache = {
    number: {},
    dateTime: {},
    pluralRules: {}
  }) {
    return {
      getNumberFormat: memoize((...args) => new Intl.NumberFormat(...args), {
        cache: createFastMemoizeCache(cache.number),
        strategy: strategies.variadic
      }),
      getDateTimeFormat: memoize((...args) => new Intl.DateTimeFormat(...args), {
        cache: createFastMemoizeCache(cache.dateTime),
        strategy: strategies.variadic
      }),
      getPluralRules: memoize((...args) => new Intl.PluralRules(...args), {
        cache: createFastMemoizeCache(cache.pluralRules),
        strategy: strategies.variadic
      })
    };
  }
  var _IntlMessageFormat = class _IntlMessageFormat {
    constructor(message, locales = _IntlMessageFormat.defaultLocale, overrideFormats, opts) {
      __publicField(this, "ast");
      __publicField(this, "locales");
      __publicField(this, "resolvedLocale");
      __publicField(this, "formatters");
      __publicField(this, "formats");
      __publicField(this, "message");
      __publicField(this, "formatterCache", {
        number: {},
        dateTime: {},
        pluralRules: {}
      });
      __publicField(this, "format", (values) => {
        const parts = this.formatToParts(values);
        if (parts.length === 1) {
          return parts[0].value;
        }
        const result = parts.reduce((all, part) => {
          if (!all.length || part.type !== PART_TYPE.literal || typeof all[all.length - 1] !== "string") {
            all.push(part.value);
          } else {
            all[all.length - 1] += part.value;
          }
          return all;
        }, []);
        if (result.length <= 1) {
          return result[0] || "";
        }
        return result;
      });
      __publicField(this, "formatToParts", (values) => formatToParts2(this.ast, this.locales, this.formatters, this.formats, values, void 0, this.message));
      __publicField(this, "resolvedOptions", () => {
        var _a2;
        return { locale: ((_a2 = this.resolvedLocale) == null ? void 0 : _a2.toString()) || Intl.NumberFormat.supportedLocalesOf(this.locales)[0] };
      });
      __publicField(this, "getAst", () => this.ast);
      this.locales = locales;
      this.resolvedLocale = _IntlMessageFormat.resolveLocale(locales);
      if (typeof message === "string") {
        this.message = message;
        if (!_IntlMessageFormat.__parse) {
          throw new TypeError("IntlMessageFormat.__parse must be set to process `message` of type `string`");
        }
        const parseOpts = __objRest(opts || {}, []);
        this.ast = _IntlMessageFormat.__parse(message, __spreadProps(__spreadValues({}, parseOpts), {
          locale: this.resolvedLocale
        }));
      } else {
        this.ast = message;
      }
      if (!Array.isArray(this.ast)) {
        throw new TypeError("A message must be provided as a String or AST.");
      }
      this.formats = mergeConfigs(_IntlMessageFormat.formats, overrideFormats);
      this.formatters = opts && opts.formatters || createDefaultFormatters(this.formatterCache);
    }
    static get defaultLocale() {
      if (!_IntlMessageFormat.memoizedDefaultLocale) {
        _IntlMessageFormat.memoizedDefaultLocale = new Intl.NumberFormat().resolvedOptions().locale;
      }
      return _IntlMessageFormat.memoizedDefaultLocale;
    }
  };
  __publicField(_IntlMessageFormat, "memoizedDefaultLocale", null);
  __publicField(_IntlMessageFormat, "resolveLocale", (locales) => {
    if (typeof Intl.Locale === "undefined") {
      return;
    }
    const supportedLocales = Intl.NumberFormat.supportedLocalesOf(locales);
    if (supportedLocales.length > 0) {
      return new Intl.Locale(supportedLocales[0]);
    }
    return new Intl.Locale(typeof locales === "string" ? locales : locales[0]);
  });
  __publicField(_IntlMessageFormat, "__parse", parse);
  // Default format options used as the prototype of the `formats` provided to the
  // constructor. These are used when constructing the internal Intl.NumberFormat
  // and Intl.DateTimeFormat instances.
  __publicField(_IntlMessageFormat, "formats", {
    number: {
      integer: { maximumFractionDigits: 0 },
      currency: { style: "currency" },
      percent: { style: "percent" }
    },
    date: {
      short: {
        month: "numeric",
        day: "numeric",
        year: "2-digit"
      },
      medium: {
        month: "short",
        day: "numeric",
        year: "numeric"
      },
      long: {
        month: "long",
        day: "numeric",
        year: "numeric"
      },
      full: {
        weekday: "long",
        month: "long",
        day: "numeric",
        year: "numeric"
      }
    },
    time: {
      short: {
        hour: "numeric",
        minute: "numeric"
      },
      medium: {
        hour: "numeric",
        minute: "numeric",
        second: "numeric"
      },
      long: {
        hour: "numeric",
        minute: "numeric",
        second: "numeric",
        timeZoneName: "short"
      },
      full: {
        hour: "numeric",
        minute: "numeric",
        second: "numeric",
        timeZoneName: "short"
      }
    }
  });
  var IntlMessageFormat = _IntlMessageFormat;

  // node_modules/.aspect_rules_js/@formatjs+intl@0.0.0/node_modules/@formatjs/intl/src/error.js
  var IntlErrorCode = function(IntlErrorCode2) {
    IntlErrorCode2["FORMAT_ERROR"] = "FORMAT_ERROR";
    IntlErrorCode2["UNSUPPORTED_FORMATTER"] = "UNSUPPORTED_FORMATTER";
    IntlErrorCode2["INVALID_CONFIG"] = "INVALID_CONFIG";
    IntlErrorCode2["MISSING_DATA"] = "MISSING_DATA";
    IntlErrorCode2["MISSING_TRANSLATION"] = "MISSING_TRANSLATION";
    return IntlErrorCode2;
  }({});
  var IntlError = class _IntlError extends Error {
    constructor(code, message, exception) {
      const err = exception ? exception instanceof Error ? exception : new Error(String(exception)) : void 0;
      super(`[@formatjs/intl Error ${code}] ${message}
${err ? `
${err.message}
${err.stack}` : ""}`);
      __publicField(this, "code");
      this.code = code;
      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, _IntlError);
      }
    }
  };
  var UnsupportedFormatterError = class extends IntlError {
    constructor(message, exception) {
      super(IntlErrorCode.UNSUPPORTED_FORMATTER, message, exception);
    }
  };
  var InvalidConfigError = class extends IntlError {
    constructor(message, exception) {
      super(IntlErrorCode.INVALID_CONFIG, message, exception);
    }
  };
  var MissingDataError = class extends IntlError {
    constructor(message, exception) {
      super(IntlErrorCode.MISSING_DATA, message, exception);
    }
  };
  var IntlFormatError = class extends IntlError {
    constructor(message, locale, exception) {
      super(IntlErrorCode.FORMAT_ERROR, `${message}
Locale: ${locale}
`, exception);
      __publicField(this, "descriptor");
      __publicField(this, "locale");
      this.locale = locale;
    }
  };
  var MessageFormatError = class extends IntlFormatError {
    constructor(message, locale, descriptor, exception) {
      super(`${message}
MessageID: ${descriptor == null ? void 0 : descriptor.id}
Default Message: ${descriptor == null ? void 0 : descriptor.defaultMessage}
Description: ${descriptor == null ? void 0 : descriptor.description}
`, locale, exception);
      __publicField(this, "descriptor");
      __publicField(this, "locale");
      this.descriptor = descriptor;
      this.locale = locale;
    }
  };
  var MissingTranslationError = class extends IntlError {
    constructor(descriptor, locale) {
      super(IntlErrorCode.MISSING_TRANSLATION, `Missing message: "${descriptor.id}" for locale "${locale}", using ${descriptor.defaultMessage ? `default message (${typeof descriptor.defaultMessage === "string" ? descriptor.defaultMessage : descriptor.defaultMessage.map((e) => {
        var _a2;
        return (_a2 = e.value) != null ? _a2 : JSON.stringify(e);
      }).join()})` : "id"} as fallback.`);
      __publicField(this, "descriptor");
      this.descriptor = descriptor;
    }
  };

  // node_modules/.aspect_rules_js/@formatjs+intl@0.0.0/node_modules/@formatjs/intl/src/utils.js
  function invariant3(condition, message, Err = Error) {
    if (!condition) {
      throw new Err(message);
    }
  }
  function filterProps(props, allowlist, defaults = {}) {
    return allowlist.reduce((filtered, name) => {
      if (name in props) {
        filtered[name] = props[name];
      } else if (name in defaults) {
        filtered[name] = defaults[name];
      }
      return filtered;
    }, {});
  }
  var defaultErrorHandler = (error) => {
    if (true) {
      console.error(error);
    }
  };
  var defaultWarnHandler = (warning) => {
    if (true) {
      console.warn(warning);
    }
  };
  var DEFAULT_INTL_CONFIG = {
    formats: {},
    messages: {},
    timeZone: void 0,
    defaultLocale: "en",
    defaultFormats: {},
    fallbackOnEmptyString: true,
    onError: defaultErrorHandler,
    onWarn: defaultWarnHandler
  };
  function createIntlCache() {
    return {
      dateTime: {},
      number: {},
      message: {},
      relativeTime: {},
      pluralRules: {},
      list: {},
      displayNames: {}
    };
  }
  function createFastMemoizeCache2(store) {
    return { create() {
      return {
        get(key) {
          return store[key];
        },
        set(key, value) {
          store[key] = value;
        }
      };
    } };
  }
  function createFormatters(cache = createIntlCache()) {
    const RelativeTimeFormat = Intl.RelativeTimeFormat;
    const ListFormat = Intl.ListFormat;
    const DisplayNames = Intl.DisplayNames;
    const getDateTimeFormat = memoize((...args) => new Intl.DateTimeFormat(...args), {
      cache: createFastMemoizeCache2(cache.dateTime),
      strategy: strategies.variadic
    });
    const getNumberFormat = memoize((...args) => new Intl.NumberFormat(...args), {
      cache: createFastMemoizeCache2(cache.number),
      strategy: strategies.variadic
    });
    const getPluralRules = memoize((...args) => new Intl.PluralRules(...args), {
      cache: createFastMemoizeCache2(cache.pluralRules),
      strategy: strategies.variadic
    });
    return {
      getDateTimeFormat,
      getNumberFormat,
      getMessageFormat: memoize((message, locales, overrideFormats, opts) => new IntlMessageFormat(message, locales, overrideFormats, __spreadValues({
        formatters: {
          getNumberFormat,
          getDateTimeFormat,
          getPluralRules
        }
      }, opts)), {
        cache: createFastMemoizeCache2(cache.message),
        strategy: strategies.variadic
      }),
      getRelativeTimeFormat: memoize((...args) => new RelativeTimeFormat(...args), {
        cache: createFastMemoizeCache2(cache.relativeTime),
        strategy: strategies.variadic
      }),
      getPluralRules,
      getListFormat: memoize((...args) => new ListFormat(...args), {
        cache: createFastMemoizeCache2(cache.list),
        strategy: strategies.variadic
      }),
      getDisplayNames: memoize((...args) => new DisplayNames(...args), {
        cache: createFastMemoizeCache2(cache.displayNames),
        strategy: strategies.variadic
      })
    };
  }
  function getNamedFormat(formats, type, name, onError) {
    const formatType = formats && formats[type];
    let format;
    if (formatType) {
      format = formatType[name];
    }
    if (format) {
      return format;
    }
    onError(new UnsupportedFormatterError(`No ${type} format named: ${name}`));
  }

  // node_modules/.aspect_rules_js/@formatjs+intl@0.0.0/node_modules/@formatjs/intl/src/message.js
  function setTimeZoneInOptions(opts, timeZone) {
    return Object.keys(opts).reduce((all, k) => {
      all[k] = __spreadValues({
        timeZone
      }, opts[k]);
      return all;
    }, {});
  }
  function deepMergeOptions(opts1, opts2) {
    const keys = Object.keys(__spreadValues(__spreadValues({}, opts1), opts2));
    return keys.reduce((all, k) => {
      all[k] = __spreadValues(__spreadValues({}, opts1[k]), opts2[k]);
      return all;
    }, {});
  }
  function deepMergeFormatsAndSetTimeZone(f1, timeZone) {
    if (!timeZone) {
      return f1;
    }
    const mfFormats = IntlMessageFormat.formats;
    return __spreadProps(__spreadValues(__spreadValues({}, mfFormats), f1), {
      date: deepMergeOptions(setTimeZoneInOptions(mfFormats.date, timeZone), setTimeZoneInOptions(f1.date || {}, timeZone)),
      time: deepMergeOptions(setTimeZoneInOptions(mfFormats.time, timeZone), setTimeZoneInOptions(f1.time || {}, timeZone))
    });
  }
  var formatMessage = ({ locale, formats, messages, defaultLocale, defaultFormats, fallbackOnEmptyString, onError, timeZone, defaultRichTextElements }, state, messageDescriptor = { id: "" }, values, opts) => {
    const { id: msgId, defaultMessage } = messageDescriptor;
    invariant3(!!msgId, `[@formatjs/intl] An \`id\` must be provided to format a message. You can either:
1. Configure your build toolchain with [babel-plugin-formatjs](https://formatjs.github.io/docs/tooling/babel-plugin)
or [@formatjs/ts-transformer](https://formatjs.github.io/docs/tooling/ts-transformer) OR
2. Configure your \`eslint\` config to include [eslint-plugin-formatjs](https://formatjs.github.io/docs/tooling/linter#enforce-id)
to autofix this issue`);
    const id = String(msgId);
    const message = messages && Object.prototype.hasOwnProperty.call(messages, id) && messages[id];
    if (Array.isArray(message) && message.length === 1 && message[0].type === TYPE.literal) {
      return message[0].value;
    }
    if (!values && message && typeof message === "string" && !defaultRichTextElements) {
      return message.replace(/'\{(.*?)\}'/gi, `{$1}`);
    }
    values = __spreadValues(__spreadValues({}, defaultRichTextElements), values);
    formats = deepMergeFormatsAndSetTimeZone(formats, timeZone);
    defaultFormats = deepMergeFormatsAndSetTimeZone(defaultFormats, timeZone);
    if (!message) {
      if (fallbackOnEmptyString === false && message === "") {
        return message;
      }
      if (!defaultMessage || locale && locale.toLowerCase() !== defaultLocale.toLowerCase()) {
        onError(new MissingTranslationError(messageDescriptor, locale));
      }
      if (defaultMessage) {
        try {
          const formatter = state.getMessageFormat(defaultMessage, defaultLocale, defaultFormats, opts);
          return formatter.format(values);
        } catch (e) {
          onError(new MessageFormatError(`Error formatting default message for: "${id}", rendering default message verbatim`, locale, messageDescriptor, e));
          return typeof defaultMessage === "string" ? defaultMessage : id;
        }
      }
      return id;
    }
    try {
      const formatter = state.getMessageFormat(message, locale, formats, __spreadValues({
        formatters: state
      }, opts));
      return formatter.format(values);
    } catch (e) {
      onError(new MessageFormatError(`Error formatting message: "${id}", using ${defaultMessage ? "default message" : "id"} as fallback.`, locale, messageDescriptor, e));
    }
    if (defaultMessage) {
      try {
        const formatter = state.getMessageFormat(defaultMessage, defaultLocale, defaultFormats, opts);
        return formatter.format(values);
      } catch (e) {
        onError(new MessageFormatError(`Error formatting the default message for: "${id}", rendering message verbatim`, locale, messageDescriptor, e));
      }
    }
    if (typeof message === "string") {
      return message;
    }
    if (typeof defaultMessage === "string") {
      return defaultMessage;
    }
    return id;
  };

  // node_modules/.aspect_rules_js/@formatjs+intl@0.0.0/node_modules/@formatjs/intl/src/dateTime.js
  var DATE_TIME_FORMAT_OPTIONS = [
    "formatMatcher",
    "timeZone",
    "hour12",
    "weekday",
    "era",
    "year",
    "month",
    "day",
    "hour",
    "minute",
    "second",
    "timeZoneName",
    "hourCycle",
    "dateStyle",
    "timeStyle",
    "calendar",
    "numberingSystem",
    "fractionalSecondDigits"
  ];
  function getFormatter({ locale, formats, onError, timeZone }, type, getDateTimeFormat, options = {}) {
    const { format } = options;
    const defaults = __spreadValues(__spreadValues({}, timeZone && { timeZone }), format && getNamedFormat(formats, type, format, onError));
    let filteredOptions = filterProps(options, DATE_TIME_FORMAT_OPTIONS, defaults);
    if (type === "time" && !filteredOptions.hour && !filteredOptions.minute && !filteredOptions.second && !filteredOptions.timeStyle && !filteredOptions.dateStyle) {
      filteredOptions = __spreadProps(__spreadValues({}, filteredOptions), {
        hour: "numeric",
        minute: "numeric"
      });
    }
    return getDateTimeFormat(locale, filteredOptions);
  }
  function formatDate(config2, getDateTimeFormat, value, options = {}) {
    const date = typeof value === "string" ? new Date(value || 0) : value;
    try {
      return getFormatter(config2, "date", getDateTimeFormat, options).format(date);
    } catch (e) {
      config2.onError(new IntlFormatError("Error formatting date.", config2.locale, e));
    }
    return String(date);
  }
  function formatTime(config2, getDateTimeFormat, value, options = {}) {
    const date = typeof value === "string" ? new Date(value || 0) : value;
    try {
      return getFormatter(config2, "time", getDateTimeFormat, options).format(date);
    } catch (e) {
      config2.onError(new IntlFormatError("Error formatting time.", config2.locale, e));
    }
    return String(date);
  }
  function formatDateTimeRange(config2, getDateTimeFormat, from, to, options = {}) {
    const fromDate = typeof from === "string" ? new Date(from || 0) : from;
    const toDate = typeof to === "string" ? new Date(to || 0) : to;
    try {
      return getFormatter(config2, "dateTimeRange", getDateTimeFormat, options).formatRange(fromDate, toDate);
    } catch (e) {
      config2.onError(new IntlFormatError("Error formatting date time range.", config2.locale, e));
    }
    return String(fromDate);
  }
  function formatDateToParts(config2, getDateTimeFormat, value, options = {}) {
    const date = typeof value === "string" ? new Date(value || 0) : value;
    try {
      return getFormatter(config2, "date", getDateTimeFormat, options).formatToParts(date);
    } catch (e) {
      config2.onError(new IntlFormatError("Error formatting date.", config2.locale, e));
    }
    return [];
  }
  function formatTimeToParts(config2, getDateTimeFormat, value, options = {}) {
    const date = typeof value === "string" ? new Date(value || 0) : value;
    try {
      return getFormatter(config2, "time", getDateTimeFormat, options).formatToParts(date);
    } catch (e) {
      config2.onError(new IntlFormatError("Error formatting time.", config2.locale, e));
    }
    return [];
  }

  // node_modules/.aspect_rules_js/@formatjs+intl@0.0.0/node_modules/@formatjs/intl/src/displayName.js
  var DISPLAY_NAMES_OPTONS = [
    "style",
    "type",
    "fallback",
    "languageDisplay"
  ];
  function formatDisplayName({ locale, onError }, getDisplayNames, value, options) {
    const DisplayNames = Intl.DisplayNames;
    if (!DisplayNames) {
      onError(new FormatError(`Intl.DisplayNames is not available in this environment.
Try polyfilling it using "@formatjs/intl-displaynames"
`, ErrorCode.MISSING_INTL_API));
    }
    const filteredOptions = filterProps(options, DISPLAY_NAMES_OPTONS);
    try {
      return getDisplayNames(locale, filteredOptions).of(value);
    } catch (e) {
      onError(new IntlFormatError("Error formatting display name.", locale, e));
    }
  }

  // node_modules/.aspect_rules_js/@formatjs+intl@0.0.0/node_modules/@formatjs/intl/src/list.js
  var LIST_FORMAT_OPTIONS = ["type", "style"];
  var now = Date.now();
  function generateToken(i) {
    return `${now}_${i}_${now}`;
  }
  function formatList(opts, getListFormat, values, options = {}) {
    const results = formatListToParts(opts, getListFormat, values, options).reduce((all, el) => {
      const val = el.value;
      if (typeof val !== "string") {
        all.push(val);
      } else if (typeof all[all.length - 1] === "string") {
        all[all.length - 1] += val;
      } else {
        all.push(val);
      }
      return all;
    }, []);
    return results.length === 1 ? results[0] : results.length === 0 ? "" : results;
  }
  function formatListToParts({ locale, onError }, getListFormat, values, options = {}) {
    const ListFormat = Intl.ListFormat;
    if (!ListFormat) {
      onError(new FormatError(`Intl.ListFormat is not available in this environment.
Try polyfilling it using "@formatjs/intl-listformat"
`, ErrorCode.MISSING_INTL_API));
    }
    const filteredOptions = filterProps(options, LIST_FORMAT_OPTIONS);
    try {
      const richValues = {};
      const serializedValues = Array.from(values).map((v, i) => {
        if (typeof v === "object" && v !== null) {
          const id = generateToken(i);
          richValues[id] = v;
          return id;
        }
        return String(v);
      });
      return getListFormat(locale, filteredOptions).formatToParts(serializedValues).map((part) => part.type === "literal" ? part : __spreadProps(__spreadValues({}, part), {
        value: richValues[part.value] || part.value
      }));
    } catch (e) {
      onError(new IntlFormatError("Error formatting list.", locale, e));
    }
    return values;
  }

  // node_modules/.aspect_rules_js/@formatjs+intl@0.0.0/node_modules/@formatjs/intl/src/plural.js
  var PLURAL_FORMAT_OPTIONS = ["type"];
  function formatPlural({ locale, onError }, getPluralRules, value, options = {}) {
    if (!Intl.PluralRules) {
      onError(new FormatError(`Intl.PluralRules is not available in this environment.
Try polyfilling it using "@formatjs/intl-pluralrules"
`, ErrorCode.MISSING_INTL_API));
    }
    const filteredOptions = filterProps(options, PLURAL_FORMAT_OPTIONS);
    try {
      return getPluralRules(locale, filteredOptions).select(value);
    } catch (e) {
      onError(new IntlFormatError("Error formatting plural.", locale, e));
    }
    return "other";
  }

  // node_modules/.aspect_rules_js/@formatjs+intl@0.0.0/node_modules/@formatjs/intl/src/relativeTime.js
  var RELATIVE_TIME_FORMAT_OPTIONS = ["numeric", "style"];
  function getFormatter2({ locale, formats, onError }, getRelativeTimeFormat, options = {}) {
    const { format } = options;
    const defaults = !!format && getNamedFormat(formats, "relative", format, onError) || {};
    const filteredOptions = filterProps(options, RELATIVE_TIME_FORMAT_OPTIONS, defaults);
    return getRelativeTimeFormat(locale, filteredOptions);
  }
  function formatRelativeTime(config2, getRelativeTimeFormat, value, unit, options = {}) {
    if (!unit) {
      unit = "second";
    }
    const RelativeTimeFormat = Intl.RelativeTimeFormat;
    if (!RelativeTimeFormat) {
      config2.onError(new FormatError(`Intl.RelativeTimeFormat is not available in this environment.
Try polyfilling it using "@formatjs/intl-relativetimeformat"
`, ErrorCode.MISSING_INTL_API));
    }
    try {
      return getFormatter2(config2, getRelativeTimeFormat, options).format(value, unit);
    } catch (e) {
      config2.onError(new IntlFormatError("Error formatting relative time.", config2.locale, e));
    }
    return String(value);
  }

  // node_modules/.aspect_rules_js/@formatjs+intl@0.0.0/node_modules/@formatjs/intl/src/number.js
  var NUMBER_FORMAT_OPTIONS = [
    "style",
    "currency",
    "unit",
    "unitDisplay",
    "useGrouping",
    "minimumIntegerDigits",
    "minimumFractionDigits",
    "maximumFractionDigits",
    "minimumSignificantDigits",
    "maximumSignificantDigits",
    "compactDisplay",
    "currencyDisplay",
    "currencySign",
    "notation",
    "signDisplay",
    "unit",
    "unitDisplay",
    "numberingSystem",
    "trailingZeroDisplay",
    "roundingPriority",
    "roundingIncrement",
    "roundingMode"
  ];
  function getFormatter3({ locale, formats, onError }, getNumberFormat, options = {}) {
    const { format } = options;
    const defaults = format && getNamedFormat(formats, "number", format, onError) || {};
    const filteredOptions = filterProps(options, NUMBER_FORMAT_OPTIONS, defaults);
    return getNumberFormat(locale, filteredOptions);
  }
  function formatNumber(config2, getNumberFormat, value, options = {}) {
    try {
      return getFormatter3(config2, getNumberFormat, options).format(value);
    } catch (e) {
      config2.onError(new IntlFormatError("Error formatting number.", config2.locale, e));
    }
    return String(value);
  }
  function formatNumberToParts(config2, getNumberFormat, value, options = {}) {
    try {
      return getFormatter3(config2, getNumberFormat, options).formatToParts(value);
    } catch (e) {
      config2.onError(new IntlFormatError("Error formatting number.", config2.locale, e));
    }
    return [];
  }

  // node_modules/.aspect_rules_js/@formatjs+intl@0.0.0/node_modules/@formatjs/intl/src/create-intl.js
  function messagesContainString(messages) {
    const firstMessage = messages ? messages[Object.keys(messages)[0]] : void 0;
    return typeof firstMessage === "string";
  }
  function verifyConfigMessages(config2) {
    if (config2.onWarn && config2.defaultRichTextElements && messagesContainString(config2.messages || {})) {
      config2.onWarn(`[@formatjs/intl] "defaultRichTextElements" was specified but "message" was not pre-compiled. 
Please consider using "@formatjs/cli" to pre-compile your messages for performance.
For more details see https://formatjs.github.io/docs/getting-started/message-distribution`);
    }
  }
  function createIntl(config2, cache) {
    const formatters = createFormatters(cache);
    const resolvedConfig = __spreadValues(__spreadValues({}, DEFAULT_INTL_CONFIG), config2);
    const { locale, defaultLocale, onError } = resolvedConfig;
    if (!locale) {
      if (onError) {
        onError(new InvalidConfigError(`"locale" was not configured, using "${defaultLocale}" as fallback. See https://formatjs.github.io/docs/react-intl/api#intlshape for more details`));
      }
      resolvedConfig.locale = resolvedConfig.defaultLocale || "en";
    } else if (!Intl.NumberFormat.supportedLocalesOf(locale).length && onError) {
      onError(new MissingDataError(`Missing locale data for locale: "${locale}" in Intl.NumberFormat. Using default locale: "${defaultLocale}" as fallback. See https://formatjs.github.io/docs/react-intl#runtime-requirements for more details`));
    } else if (!Intl.DateTimeFormat.supportedLocalesOf(locale).length && onError) {
      onError(new MissingDataError(`Missing locale data for locale: "${locale}" in Intl.DateTimeFormat. Using default locale: "${defaultLocale}" as fallback. See https://formatjs.github.io/docs/react-intl#runtime-requirements for more details`));
    }
    verifyConfigMessages(resolvedConfig);
    return __spreadProps(__spreadValues({}, resolvedConfig), {
      formatters,
      formatNumber: formatNumber.bind(null, resolvedConfig, formatters.getNumberFormat),
      formatNumberToParts: formatNumberToParts.bind(null, resolvedConfig, formatters.getNumberFormat),
      formatRelativeTime: formatRelativeTime.bind(null, resolvedConfig, formatters.getRelativeTimeFormat),
      formatDate: formatDate.bind(null, resolvedConfig, formatters.getDateTimeFormat),
      formatDateToParts: formatDateToParts.bind(null, resolvedConfig, formatters.getDateTimeFormat),
      formatTime: formatTime.bind(null, resolvedConfig, formatters.getDateTimeFormat),
      formatDateTimeRange: formatDateTimeRange.bind(null, resolvedConfig, formatters.getDateTimeFormat),
      formatTimeToParts: formatTimeToParts.bind(null, resolvedConfig, formatters.getDateTimeFormat),
      formatPlural: formatPlural.bind(null, resolvedConfig, formatters.getPluralRules),
      formatMessage: formatMessage.bind(null, resolvedConfig, formatters),
      $t: formatMessage.bind(null, resolvedConfig, formatters),
      formatList: formatList.bind(null, resolvedConfig, formatters.getListFormat),
      formatListToParts: formatListToParts.bind(null, resolvedConfig, formatters.getListFormat),
      formatDisplayName: formatDisplayName.bind(null, resolvedConfig, formatters.getDisplayNames)
    });
  }

  // packages/react-intl/src/utils.tsx
  function invariant4(condition, message, Err = Error) {
    if (!condition) {
      throw new Err(message);
    }
  }
  function invariantIntlContext(intl) {
    invariant4(
      intl,
      "[React Intl] Could not find required `intl` object. <IntlProvider> needs to exist in the component ancestry."
    );
  }
  var DEFAULT_INTL_CONFIG2 = __spreadProps(__spreadValues({}, DEFAULT_INTL_CONFIG), {
    textComponent: React.Fragment
  });
  var toKeyedReactNodeArray = (children) => {
    const childrenArray = React.Children.toArray(children);
    return childrenArray.map((child, index) => {
      if (React.isValidElement(child)) {
        return React.createElement(React.Fragment, { key: index }, child);
      }
      return child;
    });
  };
  function assignUniqueKeysToParts(formatXMLElementFn) {
    return function(parts) {
      return formatXMLElementFn(toKeyedReactNodeArray(parts));
    };
  }
  function shallowEqual(objA, objB) {
    if (objA === objB) {
      return true;
    }
    if (!objA || !objB) {
      return false;
    }
    var aKeys = Object.keys(objA);
    var bKeys = Object.keys(objB);
    var len = aKeys.length;
    if (bKeys.length !== len) {
      return false;
    }
    for (var i = 0; i < len; i++) {
      var key = aKeys[i];
      if (objA[key] !== objB[key] || !Object.prototype.hasOwnProperty.call(objB, key)) {
        return false;
      }
    }
    return true;
  }

  // packages/react-intl/src/components/injectIntl.tsx
  var hoistNonReactStaticsNs = __toESM(require_hoist_non_react_statics_cjs());
  var React2 = __toESM(window.React);
  var _a;
  var hoistNonReactStatics = (_a = hoistNonReactStaticsNs.default) != null ? _a : hoistNonReactStaticsNs;
  function getDisplayName(Component) {
    return Component.displayName || Component.name || "Component";
  }
  var IntlContext = typeof window !== "undefined" && !window.__REACT_INTL_BYPASS_GLOBAL_CONTEXT__ ? window.__REACT_INTL_CONTEXT__ || (window.__REACT_INTL_CONTEXT__ = React2.createContext(
    null
  )) : React2.createContext(null);
  var { Consumer: IntlConsumer, Provider: IntlProvider } = IntlContext;
  var Provider = IntlProvider;
  var Context = IntlContext;
  function injectIntl(WrappedComponent, options) {
    const {
      intlPropName = "intl",
      forwardRef: forwardRef2 = false,
      enforceContext = true
    } = options || {};
    const WithIntl = (props) => React2.createElement(IntlConsumer, null, (intl) => {
      if (enforceContext) {
        invariantIntlContext(intl);
      }
      const intlProp = { [intlPropName]: intl };
      return React2.createElement(
        WrappedComponent,
        __spreadProps(__spreadValues(__spreadValues({}, props), intlProp), {
          ref: forwardRef2 ? props.forwardedRef : null
        })
      );
    });
    WithIntl.displayName = `injectIntl(${getDisplayName(WrappedComponent)})`;
    WithIntl.WrappedComponent = WrappedComponent;
    if (forwardRef2) {
      return hoistNonReactStatics(
        // @ts-expect-error
        React2.forwardRef((props, ref) => React2.createElement(WithIntl, __spreadProps(__spreadValues({}, props), { forwardedRef: ref }))),
        WrappedComponent
      );
    }
    return hoistNonReactStatics(WithIntl, WrappedComponent);
  }

  // packages/react-intl/src/components/useIntl.ts
  function useIntl() {
    const intl = React3.useContext(Context);
    invariantIntlContext(intl);
    return intl;
  }

  // packages/react-intl/src/components/createFormattedComponent.tsx
  var DisplayName = /* @__PURE__ */ ((DisplayName2) => {
    DisplayName2["formatDate"] = "FormattedDate";
    DisplayName2["formatTime"] = "FormattedTime";
    DisplayName2["formatNumber"] = "FormattedNumber";
    DisplayName2["formatList"] = "FormattedList";
    DisplayName2["formatDisplayName"] = "FormattedDisplayName";
    return DisplayName2;
  })(DisplayName || {});
  var DisplayNameParts = /* @__PURE__ */ ((DisplayNameParts2) => {
    DisplayNameParts2["formatDate"] = "FormattedDateParts";
    DisplayNameParts2["formatTime"] = "FormattedTimeParts";
    DisplayNameParts2["formatNumber"] = "FormattedNumberParts";
    DisplayNameParts2["formatList"] = "FormattedListParts";
    return DisplayNameParts2;
  })(DisplayNameParts || {});
  var FormattedNumberParts = (props) => {
    const intl = useIntl();
    const _a2 = props, { value, children } = _a2, formatProps = __objRest(_a2, ["value", "children"]);
    return children(intl.formatNumberToParts(value, formatProps));
  };
  FormattedNumberParts.displayName = "FormattedNumberParts";
  var FormattedListParts = (props) => {
    const intl = useIntl();
    const _a2 = props, { value, children } = _a2, formatProps = __objRest(_a2, ["value", "children"]);
    return children(intl.formatListToParts(value, formatProps));
  };
  FormattedNumberParts.displayName = "FormattedNumberParts";
  function createFormattedDateTimePartsComponent(name) {
    const ComponentParts = (props) => {
      const intl = useIntl();
      const _a2 = props, { value, children } = _a2, formatProps = __objRest(_a2, ["value", "children"]);
      const date = typeof value === "string" ? new Date(value || 0) : value;
      const formattedParts = name === "formatDate" ? intl.formatDateToParts(date, formatProps) : intl.formatTimeToParts(date, formatProps);
      return children(formattedParts);
    };
    ComponentParts.displayName = DisplayNameParts[name];
    return ComponentParts;
  }
  function createFormattedComponent(name) {
    const Component = (props) => {
      const intl = useIntl();
      const _a2 = props, { value, children } = _a2, formatProps = __objRest(_a2, ["value", "children"]);
      const formattedValue = intl[name](value, formatProps);
      if (typeof children === "function") {
        return children(formattedValue);
      }
      const Text = intl.textComponent || React4.Fragment;
      return React4.createElement(Text, null, formattedValue);
    };
    Component.displayName = DisplayName[name];
    return Component;
  }

  // packages/react-intl/src/components/createIntl.ts
  function assignUniqueKeysToFormatXMLElementFnArgument(values) {
    if (!values) {
      return values;
    }
    return Object.keys(values).reduce((acc, k) => {
      const v = values[k];
      acc[k] = isFormatXMLElementFn(v) ? assignUniqueKeysToParts(v) : v;
      return acc;
    }, {});
  }
  var formatMessage2 = (config2, formatters, descriptor, rawValues, ...rest) => {
    const values = assignUniqueKeysToFormatXMLElementFnArgument(rawValues);
    const chunks = formatMessage(
      config2,
      formatters,
      descriptor,
      values,
      ...rest
    );
    if (Array.isArray(chunks)) {
      return toKeyedReactNodeArray(chunks);
    }
    return chunks;
  };
  var createIntl2 = (_a2, cache) => {
    var _b = _a2, { defaultRichTextElements: rawDefaultRichTextElements } = _b, config2 = __objRest(_b, ["defaultRichTextElements"]);
    const defaultRichTextElements = assignUniqueKeysToFormatXMLElementFnArgument(
      rawDefaultRichTextElements
    );
    const coreIntl = createIntl(
      __spreadProps(__spreadValues(__spreadValues({}, DEFAULT_INTL_CONFIG2), config2), {
        defaultRichTextElements
      }),
      cache
    );
    const resolvedConfig = {
      locale: coreIntl.locale,
      timeZone: coreIntl.timeZone,
      fallbackOnEmptyString: coreIntl.fallbackOnEmptyString,
      formats: coreIntl.formats,
      defaultLocale: coreIntl.defaultLocale,
      defaultFormats: coreIntl.defaultFormats,
      messages: coreIntl.messages,
      onError: coreIntl.onError,
      defaultRichTextElements
    };
    return __spreadProps(__spreadValues({}, coreIntl), {
      formatMessage: formatMessage2.bind(
        null,
        resolvedConfig,
        coreIntl.formatters
      ),
      $t: formatMessage2.bind(null, resolvedConfig, coreIntl.formatters)
    });
  };

  // packages/react-intl/src/components/dateTimeRange.tsx
  var React5 = __toESM(window.React);
  var FormattedDateTimeRange = (props) => {
    const intl = useIntl();
    const _a2 = props, { from, to, children } = _a2, formatProps = __objRest(_a2, ["from", "to", "children"]);
    const formattedValue = intl.formatDateTimeRange(from, to, formatProps);
    if (typeof children === "function") {
      return children(formattedValue);
    }
    const Text = intl.textComponent || React5.Fragment;
    return React5.createElement(Text, null, formattedValue);
  };
  FormattedDateTimeRange.displayName = "FormattedDateTimeRange";
  var dateTimeRange_default = FormattedDateTimeRange;

  // packages/react-intl/src/components/message.tsx
  var React6 = __toESM(window.React);
  function areEqual(prevProps, nextProps) {
    const _a2 = prevProps, { values } = _a2, otherProps = __objRest(_a2, ["values"]);
    const _b = nextProps, { values: nextValues } = _b, nextOtherProps = __objRest(_b, ["values"]);
    return shallowEqual(nextValues, values) && shallowEqual(otherProps, nextOtherProps);
  }
  function FormattedMessage(props) {
    const intl = useIntl();
    const { formatMessage: formatMessage3, textComponent: Text = React6.Fragment } = intl;
    const {
      id,
      description,
      defaultMessage,
      values,
      children,
      tagName: Component = Text,
      ignoreTag
    } = props;
    const descriptor = { id, description, defaultMessage };
    const nodes = formatMessage3(descriptor, values, {
      ignoreTag
    });
    if (typeof children === "function") {
      return children(Array.isArray(nodes) ? nodes : [nodes]);
    }
    if (Component) {
      return React6.createElement(Component, null, nodes);
    }
    return React6.createElement(React6.Fragment, null, nodes);
  }
  FormattedMessage.displayName = "FormattedMessage";
  var MemoizedFormattedMessage = React6.memo(
    FormattedMessage,
    areEqual
  );
  MemoizedFormattedMessage.displayName = "MemoizedFormattedMessage";
  var message_default = MemoizedFormattedMessage;

  // packages/react-intl/src/components/plural.tsx
  var React7 = __toESM(window.React);
  var FormattedPlural = (props) => {
    const { formatPlural: formatPlural2, textComponent: Text } = useIntl();
    const { value, other, children } = props;
    const pluralCategory = formatPlural2(value, props);
    const formattedPlural = props[pluralCategory] || other;
    if (typeof children === "function") {
      return children(formattedPlural);
    }
    if (Text) {
      return React7.createElement(Text, null, formattedPlural);
    }
    return formattedPlural;
  };
  FormattedPlural.displayName = "FormattedPlural";
  var plural_default = FormattedPlural;

  // packages/react-intl/src/components/provider.tsx
  var React8 = __toESM(window.React);
  function processIntlConfig(config2) {
    return {
      locale: config2.locale,
      timeZone: config2.timeZone,
      fallbackOnEmptyString: config2.fallbackOnEmptyString,
      formats: config2.formats,
      textComponent: config2.textComponent,
      messages: config2.messages,
      defaultLocale: config2.defaultLocale,
      defaultFormats: config2.defaultFormats,
      onError: config2.onError,
      onWarn: config2.onWarn,
      wrapRichTextChunksInFragment: config2.wrapRichTextChunksInFragment,
      defaultRichTextElements: config2.defaultRichTextElements
    };
  }
  var IntlProvider2 = class extends React8.PureComponent {
    constructor() {
      super(...arguments);
      __publicField(this, "cache", createIntlCache());
      __publicField(this, "state", {
        cache: this.cache,
        intl: createIntl2(processIntlConfig(this.props), this.cache),
        prevConfig: processIntlConfig(this.props)
      });
    }
    static getDerivedStateFromProps(props, { prevConfig, cache }) {
      const config2 = processIntlConfig(props);
      if (!shallowEqual(prevConfig, config2)) {
        return {
          intl: createIntl2(config2, cache),
          prevConfig: config2
        };
      }
      return null;
    }
    render() {
      invariantIntlContext(this.state.intl);
      return React8.createElement(Provider, { value: this.state.intl }, this.props.children);
    }
  };
  __publicField(IntlProvider2, "displayName", "IntlProvider");
  __publicField(IntlProvider2, "defaultProps", DEFAULT_INTL_CONFIG2);

  // packages/react-intl/src/components/relative.tsx
  var React9 = __toESM(window.React);
  var MINUTE = 60;
  var HOUR = 60 * 60;
  var DAY = 60 * 60 * 24;
  function selectUnit(seconds) {
    const absValue = Math.abs(seconds);
    if (absValue < MINUTE) {
      return "second";
    }
    if (absValue < HOUR) {
      return "minute";
    }
    if (absValue < DAY) {
      return "hour";
    }
    return "day";
  }
  function getDurationInSeconds(unit) {
    switch (unit) {
      case "second":
        return 1;
      case "minute":
        return MINUTE;
      case "hour":
        return HOUR;
      default:
        return DAY;
    }
  }
  function valueToSeconds(value, unit) {
    if (!value) {
      return 0;
    }
    switch (unit) {
      case "second":
        return value;
      case "minute":
        return value * MINUTE;
      default:
        return value * HOUR;
    }
  }
  var INCREMENTABLE_UNITS = [
    "second",
    "minute",
    "hour"
  ];
  function canIncrement(unit = "second") {
    return INCREMENTABLE_UNITS.indexOf(unit) > -1;
  }
  var SimpleFormattedRelativeTime = (props) => {
    const { formatRelativeTime: formatRelativeTime2, textComponent: Text } = useIntl();
    const _a2 = props, { children, value, unit } = _a2, otherProps = __objRest(_a2, ["children", "value", "unit"]);
    const formattedRelativeTime = formatRelativeTime2(value || 0, unit, otherProps);
    if (typeof children === "function") {
      return children(formattedRelativeTime);
    }
    if (Text) {
      return React9.createElement(Text, null, formattedRelativeTime);
    }
    return React9.createElement(React9.Fragment, null, formattedRelativeTime);
  };
  var FormattedRelativeTime = (_a2) => {
    var _b = _a2, {
      value = 0,
      unit = "second",
      updateIntervalInSeconds
    } = _b, otherProps = __objRest(_b, [
      "value",
      "unit",
      "updateIntervalInSeconds"
    ]);
    invariant4(
      !updateIntervalInSeconds || !!(updateIntervalInSeconds && canIncrement(unit)),
      "Cannot schedule update with unit longer than hour"
    );
    const [prevUnit, setPrevUnit] = React9.useState();
    const [prevValue, setPrevValue] = React9.useState(0);
    const [currentValueInSeconds, setCurrentValueInSeconds] = React9.useState(0);
    const updateTimer = React9.useRef(void 0);
    if (unit !== prevUnit || value !== prevValue) {
      setPrevValue(value || 0);
      setPrevUnit(unit);
      setCurrentValueInSeconds(
        canIncrement(unit) ? valueToSeconds(value, unit) : 0
      );
    }
    React9.useEffect(() => {
      function clearUpdateTimer() {
        clearTimeout(updateTimer.current);
      }
      clearUpdateTimer();
      if (!updateIntervalInSeconds || !canIncrement(unit)) {
        return clearUpdateTimer;
      }
      const nextValueInSeconds = currentValueInSeconds - updateIntervalInSeconds;
      const nextUnit = selectUnit(nextValueInSeconds);
      if (nextUnit === "day") {
        return clearUpdateTimer;
      }
      const unitDuration = getDurationInSeconds(nextUnit);
      const remainder = nextValueInSeconds % unitDuration;
      const prevInterestingValueInSeconds = nextValueInSeconds - remainder;
      const nextInterestingValueInSeconds = prevInterestingValueInSeconds >= currentValueInSeconds ? prevInterestingValueInSeconds - unitDuration : prevInterestingValueInSeconds;
      const delayInSeconds = Math.abs(
        nextInterestingValueInSeconds - currentValueInSeconds
      );
      if (currentValueInSeconds !== nextInterestingValueInSeconds) {
        updateTimer.current = setTimeout(
          () => setCurrentValueInSeconds(nextInterestingValueInSeconds),
          delayInSeconds * 1e3
        );
      }
      return clearUpdateTimer;
    }, [currentValueInSeconds, updateIntervalInSeconds, unit]);
    let currentValue = value || 0;
    let currentUnit = unit;
    if (canIncrement(unit) && typeof currentValueInSeconds === "number" && updateIntervalInSeconds) {
      currentUnit = selectUnit(currentValueInSeconds);
      const unitDuration = getDurationInSeconds(currentUnit);
      currentValue = Math.round(currentValueInSeconds / unitDuration);
    }
    return React9.createElement(
      SimpleFormattedRelativeTime,
      __spreadValues({
        value: currentValue,
        unit: currentUnit
      }, otherProps)
    );
  };
  FormattedRelativeTime.displayName = "FormattedRelativeTime";
  var relative_default = FormattedRelativeTime;

  // packages/react-intl/index.ts
  function defineMessages(msgs) {
    return msgs;
  }
  function defineMessage(msg) {
    return msg;
  }
  var FormattedDate = createFormattedComponent("formatDate");
  var FormattedTime = createFormattedComponent("formatTime");
  var FormattedNumber = createFormattedComponent("formatNumber");
  var FormattedList = createFormattedComponent("formatList");
  var FormattedDisplayName = createFormattedComponent("formatDisplayName");
  var FormattedDateParts = createFormattedDateTimePartsComponent("formatDate");
  var FormattedTimeParts = createFormattedDateTimePartsComponent("formatTime");
  return __toCommonJS(react_intl_exports);
})();
/*! Bundled license information:

react-is/cjs/react-is.development.js:
  (** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

decimal.js/decimal.mjs:
  (*!
   *  decimal.js v10.6.0
   *  An arbitrary-precision Decimal type for JavaScript.
   *  https://github.com/MikeMcl/decimal.js
   *  Copyright (c) 2025 Michael Mclaughlin <M8ch88l@gmail.com>
   *  MIT Licence
   *)
*/
//# sourceMappingURL=react-intl.esbuild.iife.js.map
